INSERT INTO question (question, answer, theme, is_impotent)
VALUES ('Что такое ООП', 'ООП - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.\n\n
Согласно парадигмы ООП программа состоит из обьектов, обменивающихся сообщениями. Обьекты могут обладать состоянием, единственный способ изменить состояние обьекта - передать ему сообщение,  в ответ на которое, обьект может изменить собственное состояние.\n\n
Класс — это описание еще не созданного объекта, как бы общий шаблон, состоящий из полей, методов и конструктора, а объект – экземпляр класса, созданный на основе этого описания.',
        'CORE1', true),
       ('Какие преимущества у ООП', '1. Легко читается - не нужно выискивать в коде функции и выяснять, за что они отвечают\n\n
2. Быстро пишется - можно быстро создать сущности, с которыми должна работать программа.\n\n
3. Простота реализации большого функционала - т.к. на написание кода уходит меньше времени, можно гораздо быстрее создать приложение с множеством возможностей\n\n
4. Меньше повторений кода - не нужно писать однотипные функции для разных сущностей', 'CORE1', false),
       ('Какие недостатки у ООП', '1. Потребление памяти - обьекты потребляют больше оперативной памяти, чем примитивные типы данных\n\n
2. Снижает производительность - многие вещи технически реализованы иначе, поэтому они используют больше ресурсов.\n\n
3. Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).\n\n
4. Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе. А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.\n\n
5. Сложно начать - парадигма ООП сложнее функционального программирования, поэтому на старт уходит больше времени',
        'CORE1', false),
       ('Назовите основные принципы ООП', 'Инкапсуляция, Наследование, Полиморфизм', 'CORE1', true),
       ('Что такое инкапсуляция?', 'Инкапсуляция - Свойство системы, которое объединяет данные и методы, манипулирующие этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.\n\n
Инкапсуляция - это объединение данных и методов работы с этими данными в одной упаковке («капсуле»).\n\n
Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.', 'CORE1', true),
       ('Что такое наследование?',
        'Наследование - Свойство системы, которое позволяет описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.',
        'CORE1', true),
       ('Что такое полиморфизм? ', '\tПолиморфизм — это концепция ООП, которая позволяет объектам разных классов быть обработанными через единый интерфейс или базовый класс. В Java полиморфизм достигается на двух уровнях: во время компиляции (статический полиморфизм) и во время выполнения (динамический полиморфизм).\n\n
\t1. Статический полиморфизм (compile-time polymorphism): Основывается на методах перегрузки (method overloading). Java выбирает, какой из перегруженных методов вызывать, во время компиляции, основываясь на сигнатуре метода (количестве и типе параметров).\n
                                   \t2. Динамический полиморфизм (runtime polymorphism): Основывается на методах переопределения (method overriding). Java определяет, какой метод вызывать, во время выполнения программы. Обычно это достигается через виртуальные методы и наследование.',
        'CORE1', true),
       ('Что такое ассоциация', 'Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». Автомобиль имеет двигатель. Вполне естественно, что он не будет являться наследником двигателя (хотя такая архитектура тоже возможна в некоторых ситуациях).\n\n
Выделяют два частных случая ассоциации: композицию и агрегацию.', 'CORE1', false),
       ('Что такое композиция',
        'Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.',
        'CORE1', false),
       ('Что такое агрегация',
        'Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра.',
        'CORE1', false),
       ('Расскажите про раннее и позднее связывание.', 'Связывание означает наличие связи между ссылкой и кодом. Например, переменная, на которую вы ссылаетесь, привязана к коду, в котором она определена. Аналогично, вызываемый метод привязан к месту в коде, где он определен.\n\n
Раннее связывание - Если метод известен компилятору,  то происходит ранее связывание на этапе компиляции (early binding), также называют статическим связыванием. Используется для final, перегруженных, статических методов.\n\n
Позднее связывание (late binding) - вызов метода возможен только во время выполнения, т.к. у компилятора нет информации, чтобы проверить корректность такого вызова. В java это возможно при помощи рефлексии. Используется для переопределенных и абстрактных методов.\n\n
 Вот пример: Object a = ... // какое-то присваивание a.toString(); На этапе компиляции мы не знаем, какого типа объект a. Он может быть как собственно Object, так и любым его наследником, в котором метод toString() переопределён. Именно на этапе выполнения определяется тип a и вызывается toString() из того класса, какого типа объект a. Это и есть позднее связывание.\n\n
В случае статического связывания используются не конкретные объекты, а информация о типе, то есть используется тип ссылочной переменной. С другой стороны, при динамическом связывании для нахождения нужного метода используется конкретный объект.\n\n
Исходя из того, что раннее связывание выполняется на этапе компиляции, а позднее - в рантайме, первый вариант обладает лучшим быстродействием, однако второй необходим для реализации полиморфизма.',
        'CORE1', false),
       ('SOLID', 'SOLID — это акроним, образованный из заглавных букв первых пяти принципов ООП и проектирования.\n\n
S(Single Responsibility Principle) - принцип единственной ответственности - каждый класс выполняет лишь одну задачу. Легкая модификация в будущем, простое тестирование, класс не имеет зависимостей на другие классы.\n\n
O(Open Closed Principle) - принцип открытости/закрытости - программные сущности открыты для расширения и закрыты для модификации. Чтобы не сломать логику в классе-родителе, мы унаследуемся от него и реализуем что-то своё, и используем свой класс.\n\n
L(Liskov’s Substitution Principle) - принцип подстановки барбары лисков -  объекты в программе можно заменить их наследниками без изменения свойств программы.\n\n
I(Interface Segregation Principle) - принцип разделения интерфейса - много специализированных интерфейсов лучше, чем один общий\n\n
D(Dependency Inversion Principle) - принцип инверсии зависимостей - зависимость на абстракциях. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.',
        'CORE1', true),
       ('Какая основная идея языка?',
        '«Написано однажды - работает везде». Идея основывается в написании одного кода, который будет работать на любой платформе.',
        'CORE1', false),
       ('За счет чего обеспечивается кроссплатформенность?',
        'Кроссплатформенность была достигнута за счёт создания виртуальной машина Java. Java Virtual Machine или JVM - это программа, являющаяся прослойкой между операционной системой и Java программой. В среде виртуальной машины выполняются коды Java программ. Сама JVM реализована для разных ОС. Что байт код для JVM может исполняться везде где установлена JVM. Код не нужно перекомпилировать под каждую из платформ.',
        'CORE1', false),
       ('Какие преимущества у java?', 'Объектно-ориентированное программирование - структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.\n\n
Стандарт для корпоративных вычислительных систем - корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.\n\n
Безопасность - благодарю отсутсвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").\n\n
Независимость от платформы - Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.\n\n
Язык для распределенного программирования и комфортной удаленной совместной работы - Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения CORBA для обмена объектами между программами, написанными на разных языках.\n\n
Автоматическое управление памятью - Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).\n\n
Многопоточность - Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.',
        'CORE1', false),
       ('Какие недостатки у java?', 'Платное коммерческое использование (с 2019)\n\n
Низкая производительность - из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти.\n\n
Не развитые инструменты по созданию GUI приложений на чистой java.\n\n
Многословный код. Java — это более легкая версия неприступного C ++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.',
        'CORE1', false),
       ('Что такое JDK? Что в него входит?', 'JDK (Java Development Kit) - включает JRE и набор инструментов разработчика приложений на языке Java:\n\n
- компилятор Java (javac)\n\n
- стандартные библиотеки классов java\n\n
- примеры\n\n
- документацию\n\n
- различные утилиты', 'CORE1', false),
       ('Что такое JRE? Что в него входит?',
        'JRE (java Runtime Environment) - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений. Состоит из JVM, ClassLoader и стандартного набора библиотек и классов Java',
        'CORE1', false),
       ('Что такое JVM?', 'JVM (Java Virtual Machine) - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода JIT компилятором, с помощью встроенного интерпретатора байткода.\n\n
HotSpot представляет собой реализацию концепции JVM.', 'CORE1', false),
       ('Что такое byte code?', 'Байт-код Java — набор инструкций, скомпилированный компилятором, исполняемый JVM. ',
        'CORE1', false),
       ('Что такое загрузчик классов (classloader)?', 'Загрузчик классов (classloader) в Java - это компонент виртуальной машины Java (JVM), который ответственен за загрузку классов в память приложения. Каждый класс, используемый в Java программе, загружается загрузчиком классов, который находится внутри JVM.\n\n Используется для передачи в JVM скомпилированного байт-кода, хранится в файлах с расширением .class\n\n
При запуске JVM, используются три загрузчика классов:\n\n
- Bootstrap ClassLoader - базовый загрузчик - загружает платформенные классы JDK из архива rt.jar\n\n
- AppClassLoader - системный загрузчик (3) - загружает классы приложения, определенные в CLASSPATH\n\n
- Extension ClassLoader - загрузчик расширений (2) - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n\n
ClassLoader выполняет три основных действия в строгом порядке:\n\n
1. Загрузка: находит и импортирует двоичные данные для типа.\n\n
2. Связывание: выполняет проверку, подготовку и (необязательно) разрешение.\n\n
3. Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.\n\n
Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.',
        'CORE1', true),
       ('Что такое JIT?',
        'JIT (Just-In-Time) компилятор в Java - это компонент виртуальной машины Java (JVM), который переводит байт-код Java в машинный код во время выполнения программы. JIT-компиляция позволяет оптимизировать производительность приложения, поскольку ускоряет выполнение кода за счет компиляции только необходимых методов в машинный код на лету.',
        'CORE1', false),
       ('Что такое сборщик мусора? (Garbage collector)', 'Сборщик мусора выполняет две задачи: - поиск мусора; - очистка мусора.\n\n
Области памяти Кучи:\n
1. Молодое поколение (Young Generation) - это область кучи, где размещаются недавно созданные объекты. Объекты, которые "выживают" после сборки мусора в молодом поколении, переносятся в следующее поколение. Молодое поколение состоит из следующих частей:\n
   - Eden Space - сюда помещаются новые объекты.\n
   - Survivor Space (from/to) - здесь хранятся объекты, пережившие одну или несколько сборок мусора в молодом поколении.\n\n
2. Старое поколение (Old Generation) - это область кучи, куда переносятся объекты, "пережившие" несколько сборок мусора в молодом поколении. Это более стабильные и долгоживущие объекты.\n\n
3. Постоянное поколение (Permanent Generation) - это область памяти, используемая для хранения метаданных JVM, таких как классы и методы. В Java 8 и более поздних версиях постоянное поколение было заменено на Метаспейс (Metaspace).\n\n
Процессы сборки мусора разделяются несколько видов:\n\n
        1. minor GC (малая) - частый и быстрый, работает только с областью памяти "young generation";\n\n
         - приложение приостанавливается на начало сборки мусора (такие остановки называются stop-the-world);\n
         - «живые» объекты из Eden перемещаются в область памяти «To»;\n
         - «живые» объекты из «From» перемещаются в «To» или в «old generation», если они достаточно «старые»;\n
         - Eden и «From» очищаются от мусора;\n
         - «To» и «From» меняются местами;\n
         - приложение возобновляет работу.\n\n
        2. major GC (старшая) - редкий и более длительный, затрагивает объекты старшего поколения. В принцип работы «major GC» добавляется процедура «уплотнения», позволяющая более эффективно использовать память. В процедуре живые объекты перемещаются в начало. Таким образом, мусор остается в конце памяти.\n\n
        full GC (полная) -  полный сборщик мусора сначала запускает Minor, а затем Major (хотя порядок может быть изменен, если старое поколение заполнено, и в этом случае он освобождается первым, чтобы позволить ему получать объекты от молодого поколения',
        'CORE1', true),
       ('Виды ссылок в Java', '1) StrongReference — это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.         StringBuilder builder = new StringBuilder(); - builder это и есть strong-ссылка на объект StringBuilder.Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора.\n\n
2) SoftReference —  GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит OutOfMemoryError. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.\n\n
   StringBuilder builder = new StringBuilder();\n\n
   SoftReference<StringBuilder> softBuilder = new SoftReference(builder);\n\n
   softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В другом случае вернется null.\n\n
   softBuilder.clear() — удалит ссылку на объект StringBuilder То же самое работает для WeakReference.\n\n
3) WeakReference — если GC видит, что объект доступен только через цепочку weak-ссылок (исчезнули strong-ссылки), то он удалит его из памяти.',
        'CORE1', false),
       ('Stack и Heap', 'В Java, стек (stack) используется для хранения локальных переменных и вызовов методов. Каждый поток выполнения программы имеет свой собственный стек. Переменные на стеке имеют кратковременную жизнь и удаляются после выхода из метода.\n\n
Куча (heap) в Java используется для хранения объектов и доступна всем потокам. Память в куче выделяется для объектов и освобождается сборщиком мусора, когда объект больше не используется. Переменные ссылочного типа (например, объекты класса) хранятся в куче, а сами объекты на которые они ссылаются также лежат в куче.',
        'CORE1', true),
       ('Какие примитивные типы данных есть в Java? Вопрос чтобы отсеить дурака', 'В Java существует 8 примитивных типов данных:\n\n
1. byte: 8-битное целое число от -128 до 127.\n\n
2. short: 16-битное целое число от -32,768 до 32,767.\n\n
3. int: 32-битное целое число от -2,147,483,648 до 2,147,483,647.\n\n
4. long: 64-битное целое число от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807.\n\n
5. float: 32-битное число с плавающей запятой от ~3.4e-38 до ~3.4e38.\n\n
6. double: 64-битное число с плавающей запятой от ~1.7e-308 до ~1.7e308.\n\n
7. boolean: логический тип данных, принимающий значение true или false.\n\n
8. char: 16-битный символ Unicode от 0 до 65,535.\n\n
Каждый примитивный тип данных имеет фиксированный размер и диапазон значений, который определяет, какие значения он может хранить.',
        'CORE1', true),
       ('Что такое char?', '16-разрядное беззнаковое целое, представляющее собой символ UTF-16 (буквы и цифры)',
        'CORE1', false),
       ('Сколько памяти занимает boolean?',
        'Зависит от реализации JVM. В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.',
        'CORE1', false),
       ('Что такое классы-обертки?',
        'Обертка — это специальный класс, который хранит внутри себя значение примитива(объекты классов-оберток являются неизменяемыми (Immutable)). Нужны для реализации дженериков.',
        'CORE1', false),
       ('Что такое автоупаковка и автораспаковка?', 'Автоупаковка - присвоение классу обертки значения примитивного типа;\n\n
Автораспаковка - присвоение переменной примитивного типа значение класса обертки.\n\n
для присваивания ссылок-примитивов объектам их классов-оберток (и наоборот) не требуется ничего делать, все происходит автоматически. Для того, чтобы иметь возможность оперировать с простыми числами (и boolean) как с объектами были придуманы классы-обёртки.',
        'CORE1', false),
       ('Что такое явное и неявное приведение типов? В каких случаях в java нужно использовать явное приведение?', 'Неявное приведение – автоматическое расширение типа переменной от меньшего к большему.\n\n
Явное приведение -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.long l = (long)d; //explicit type casting int i = (int)l;\n\n
В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.',
        'CORE1', false),
       ('Что такое пул интов?', 'В Java есть пул(pool) целых чисел в промежутке [-128;127], так как это самый часто вречающийся диапазон. Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.\n\n
Изменить размер кэша в HotSpot вы можете, указав ключ -XX:AutoBoxCacheMax=<размер>. ( внастройках JVM)', 'CORE1',
        false),
       ('Какие нюансы у строк в Java?',
        'Класс String в Java -  неизменяемый из-за модификатора final и отсутствия сеттера. Это нужно для реализации пула стрингов. При редактировании будет создаваться новая строка. При копировании новая строка не создается, а создается ссылка на существующую строку.',
        'CORE1', false),
       ('Что такое пул строк?', 'Область памяти где хранятся обьекты строк.\n\n
При создании в пуле идет поиск строки:\n\n
-если НЕ находит -  создается строка, возращается ссылка\n\n
-если находит - возращает ссылку найденной строки.\n\n
При этом использование оператора new заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.\n\n
Пул строк и Integer хранится в heap, но ссылки на объекты хранятся в stack.', 'CORE1', false),
       ('Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?',
        'Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый обьект строки. Рекомендуется использовать StringBuilder или StringBuffer.',
        'CORE1', false),
       ('Почему строки не рекомендуется использовать для хранения паролей?', '1. Пул строк. Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.\n\n
2. Рекомендации авторов. Java сама по себе рекомендует использовать метод getPassword () из класса JPasswordField, который возвращает char [].\n\n
3. Случайная печать в логах. С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.',
        'CORE1', false),
       ('Почему String неизменяемый и финализированный класс?', '1. Для возможности реализации строкового пула (String pool)\n
Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.\n\n
2. Безопасность\n
Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.\n\n
3. Для многопоточности. Неизменяемые строки потокобезопасны\n
Так как строка неизменяемая то, она безопасна для много поточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.\n\n
4. Ключ для HashMap\n
Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.\n\n
- можно передавать строку между потоками не опасаясь, что она будет изменена\n\n
- отсутствуют проблемы с синхронизацией потоков\n\n
- отсутствие проблем с  утечкой памяти\n\n
- отсутствие проблем с доступом и безопасностью при использовании строк для передачи параметров авторизации, открытия файлов и т.д.\n\n
- кэширование hashcode\n\n
- Экономия памяти при использовании пула строк для хранения повторяющихся строк.', 'CORE1', true),
       ('Почему строка является популярным ключом в HashMap в Java?',
        'Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета.',
        'CORE1', false),
       ('Что делает метод intern() в классе String?', 'Помещает строку в pool строк.', 'CORE1', false),
       ('Можно ли использовать строки в конструкции switch?', 'Да, начиная с Java 7 в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.\n\n
При этом:\n\n
- участвующие строки чувствительны к регистру;\n\n
- использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else\n\n
- оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException.',
        'CORE1', false),
       ('Какая основная разница между String, StringBuffer, StringBuilder?', 'String - неизменяемый, потокобезопасный;\n\n
StringBuffer - изменяемый, потокобезопасный;\n\n
StringBuilder - изменяемый, потоконебезопасный.', 'CORE1', false),
       ('Существуют ли в java многомерные массивы?', 'Многомерные массивы в их классическом понимании в java не существуют.\n\n
Многомерный массив всегда прямоугольный и неразрывен в памяти. А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.',
        'CORE1', false),
       ('Какими значениями инициируются переменные по умолчанию?', 'byte 0\n\n
short 0\n\n
int 0\n\n
long 0L\n\n
float 0.0f\n\n
double 0.0d\n\n
char \u0000\n\n
boolean false\n\n
Обьекты null\n\n
Локальные (в методе) переменные не имеют значений по умолчанию, их имеют поля класса.\n\n
Не static-поле класса будет инициализировано после того, как будет создан объект этого класса. А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.',
        'CORE1', false),
       ('Что такое сигнатура метода?', 'Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним). В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.\n\n
А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.',
        'CORE1', false),
       ('Расскажите про метод main', 'Является, как правило, точкой входа в программу и вызывается JVM.\n\n
Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.\n\n
static - чтобы JVM смогла загрузить его во время компиляции.\n\n
public static void и сигнатура - обязательное декларирование.\n\n
Мэйнов может быть много и может не быть вообще.\n\n
Может быть перегружен.', 'CORE1', false),
       ('Каким образом переменные передаются в методы, по значению или по ссылке? Очень важный вопрос, часто используется для проверки на дурака',
        'Java передает параметры по значению. Всегда. С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.',
        'CORE1', true),
       ('Какие виды классов есть в java?', '1. Вложенные классы – нестатические классы внутри внешнего класса.\n\n
2. Вложенные статические классы – статические классы внутри внешнего класса.\n\n
3. Локальные классы Java – классы внутри методов. разница между локальным и внутреним\n\n
4. Анонимные Java классы – классы, которые создаются на ходу. Анонимные классы доступно\n\n
5. Final, abstract, enum - классы', 'CORE1', false),
       ('Расскажите про вложенные классы. В каких случаях они применяются?', 'Нужны для обслуживания внешних классов\n\n
1. Статические вложенные классы (Static nested classes)\n\n
   - Есть возможность обращения к внутренним статическим полям и методам класса обертки.\n\n
2. Вложенные классы\n\n
   - Есть возможность обращения к внутренним полям и методам класса обертки.\n\n
   - Не может иметь статических объявлений.\n\n
   - Внутри такого класса нельзя объявить перечисления.\n\n
   - Если нужно явно получить this внешнего класса — OuterClass.this\n\n
3. Локальный класс\n\n
   - Видны только в пределах блока, в котором объявлены.\n\n
   - Не могут быть объявлены как private/public/protected или static (по этой причине интерфейсы нельзя объявить локально).\n\n
   - Не могут иметь внутри себя статических объявлений (полей, методов, классов), но могут иметь константы (static final)\n\n
   - Имеют доступ к полям и методам обрамляющего класса.\n\n
   - Можно обращаться к локальным переменным и параметрам метода, если они объявлены с модификатором final или являются effectively final.\n\n
   - Анонимные классы\n\n
   - Локальный класс без имени.', 'CORE1', false),
       ('- Что такое «локальный класс»? Каковы его особенности?', 'Данные классы объявляются внутри других методов. Они обладают всеми свойствами нестатического вложенного класса, только создавать их экземпляры можно только в методе.\n\n
Особенности:
Локальные классы способны работать только с final переменными метода.\n\n
С 8+ версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут изменяться.\n\n
Локальные классы нельзя объявлять с модификаторами доступа.\n\n
Локальные классы обладают доступом к переменным метода.\n\n
Может быть создан внутри блоков инициализации.', 'CORE1', false),
       ('Что такое «анонимные классы»? Где они применяются?', '\tАнонимные классы - это вложенный локальный класс без имени в Java, которые позволяют определить и создать экземпляр класса одновременно. Анонимные классы полезны в случаях, когда требуется создать класс один раз и не планируется его повторное использование.\n\n
\tОсновные характеристики анонимных классов:\n
1. Они не имеют имени и создаются inline (на месте использования).\n
2. Часто используются для реализации интерфейсов или наследования от классов абстрактного типа.\n
3. Могут содержать содержание в виде методов и переопределений.\n\n
Пример использования анонимного класса:\n\n
interface Greeting {\n
    \tvoid greet();\n
}\n\n

public class Main {\n
    \tpublic static void main(String[] args) {\n
        \t\tGreeting greeting = new Greeting() {\n
            \t\t\t@Override\n
            \t\t\tpublic void greet() {\n
                \t\t\t\tSystem.out.println("Hello, World!");\n
            \t\t\t}\n
        \t\t};\n\n

        \t\tgreeting.greet();\n
    \t}\n
}\n\n

\tАнонимные классы часто применяются в разработке GUI приложений (например, обработчики событий) и при реализации стратегий или шаблонов проектирования. Они позволяют упростить код, избежать создания лишних классов и сделать код более компактным и лаконичным. В документации Oracle приведена хорошая рекомендация: «Применяйте анонимные классы, если вам нужен локальный класс для одноразового использования». ',
        'CORE1', true),
       ('- Каким образом из вложенного класса получить доступ к полю внешнего класса?', 'Статический вложенный класс имеет прямой доступ только к статическим полям обрамляющего класса.\n\n
Простой вложенный класс, может обратиться к любому полю внешнего класса напрямую.\n\n
В случае, если у вложенного класса уже существует поле с таким же литералом, то обращаться к внешнему полю следует через имя внешнего класса. Например: Outer.this.field.',
        'CORE1', false),
       ('Что такое перечисления (enum)?', 'Перечисления представляют набор логически связанных констант.\n\n
Перечисление фактически представляет новый класс, поэтому мы можем определить переменную данного типа и использовать ее.\n\n
Перечисления, как и обычные классы, могут определять конструкторы, поля и методы.\n\n
Следует отметить, что конструктор по умолчанию приватный. Также можно определять методы для отдельных констант.\n\n
Методы:\n\n
-ordinal() возвращает порядковый номер определенной константы (нумерация начинается с 0)\n\n
-values() возвращает массив всех констант перечисления\n\n
Еnum имеет ряд преимуществ при использовании в сравнении с static final int.\n\n
Главным отличием является то что используя enum вы можете проверить тип данных.\n\n
Недостатки\n\n
-  К ним не применимы операторы >, <, >=, <= \n\n
- enum также требует больше памяти для хранения чем обычная константа.\n\n
Нужны для ограничения области допустимых значений: например, времена года, дни недели', 'CORE1', false),
       ('Как проблема ромбовидного наследования решена в java?', 'В Java нет поддержки множественного наследования классов.\n\n
Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.\n\n
1. Классы всегда побеждают: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.\n\n
2. Если не срабатывает правило 1, то побеждают саб-интерфейсы (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.\n\n
3. Если оба правила не работают, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать, иначе компилятор будет сильно материться.',
        'CORE1', false),
       ('Что такое конструктор по умолчанию?', 'Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».\n\n
Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.',
        'CORE1', false),
       ('Могут ли быть приватные конструкторы? Для чего они нужны?', 'Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса.\n\n
Нужен для реализации паттернов, например singleton.', 'CORE1', false),
       ('Расскажите про классы-загрузчики и про динамическую загрузку классов.', 'При запуске JVM, используются три загрузчика классов:\n\n
- Bootstrap ClassLoader - главный загрузчик - загружает платформенные классы JDK из архива rt.jar\n\n
- AppClassLoader - системный загрузчик - загружает классы приложения, определенные в CLASSPATH\n\n
- Extension ClassLoader - загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext.\n\n
Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().',
        'CORE1', true),
       ('Чем отличаются конструкторы по-умолчанию, конструктор копирования и конструктор с параметрами?', '-У конструктора по умолчанию отсутствуют какие-либо аргументы. \n\n
-Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.\n\n
-Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).',
        'CORE1', false),
       ('Какие модификаторы доступа есть в Java? Какие применимы к классам?', 'Private – доступ к компоненту только из этого класса, в котором объявлен.\n\n
Default – Переменная или метод будут доступны для любого другого класса в том же пакете.\n\n
Protected – Поля protected доступны всем классам внутри пакета, а также всем классам-наследникам вне пакета.\n\n
Public – доступ к компоненту из экземпляра любого класса и любого пакета.\n\n
Класс может быть объявлен с модификатором public и default.', 'CORE1', false),
       ('Что означает модификатор static?', 'Статическая переменная - это переменная, принадлежащая классу, а не объекту.\n\n
А статический класс- это вложенный класс, который может обращаться только к статическим полям обертывающего его класса.\n\n
Внутри static метода нельзя вызвать не статический метод по имени класса.', 'CORE1', false),
       ('Может ли статический метод быть переопределён или перегружен', 'Нельзя переопределять статические методы.\n\n
Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса  вместо переопределения. Это явление известно как сокрытие методов (hiding methods).\n\n
Перегружен - да. Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.',
        'CORE1', false),
       ('Могут ли нестатические методы перегрузить статические?',
        'Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.', 'CORE1',
        false),
       ('Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?', 'При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.\n\n
Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например, если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.',
        'CORE1', false),
       ('Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?', 'В сигнатуре(имя + параметры) менять ничего нельзя.\n\n
Возможно расширение уровня доступа.\n\n
Изменять тип возвращаемого значения при переопределении метода разрешено только в сторону сужения типа (вместо родительского класса - наследника).\n\n
Секцию throws метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса. Так же, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.',
        'CORE1', false),
       ('Могут ли классы быть статическими?', 'Класс можно объявить статическим за исключением классов верхнего уровня.\n\n
Такие классы известны как «вложенные статические классы» (nested static class). ', 'CORE1', false),
       ('Что означает модификатор final? К чему он может быть применим?', 'Для класса это означает, что класс не сможет иметь подклассов, т.е. запрещено наследование. \n\n
Следует также отметить, что к abstract-классам нельзя применить модификатор final, т.к. это взаимоисключающие понятия.\n\n
Для переменных примитивного типа это означает, что однажды присвоенное значение не может быть изменено\n\n
Для ссылочных переменных это означает, что после присвоения объекта, нельзя изменить ссылку на данный объект. Важно: Ссылку изменить нельзя, но состояние объекта изменять можно.\n\n
Т.к. массив – это объект, то final означает, что после присвоения ссылки на объект, уже нельзя ее изменить, но можно изменять состояние объекта.',
        'CORE1', false),
       ('Что такое абстрактные классы? Чем они отличаются от обычных?', 'Абстрактным называется класс, на основе которого не могут создаваться объекты.\n\n
Как обычный класс, но с абстрактными методами.\n\n
Нельзя создать объект или экземпляр абстрактного класса.\n\n
Наследниками абстрактного класса могут быть другие абстрактные классы', 'CORE1', false),
       ('Может ли быть абстрактный класс без абстрактных методов?',
        'Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.',
        'CORE1', false),
       ('Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?', 'Да. Необходимы для наследников.\n\n
В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.',
        'CORE1', false),
       ('Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?', 'Интерфейс — это план класса или, можно сказать, набор абстрактных методов и статических констант. В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.\n\n
- методы интерфейса являются публичными (public) и абстрактными (abstract)\n\n
- поля — public static final.', 'CORE1', false),
       ('Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?', '1. Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.\n\n
2. Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.\n\n
3. Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.\n\n
4. Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8й версии.',
        'CORE1', false),
       ('Может ли один интерфейс наследоваться от другого? От двух других?',
        'Да, может. Используется ключевое слово extends', 'CORE1', false),
       ('Что такое дефолтные методы интерфейсов? Для чего они нужны?', 'В JDK 8 была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости.\n\n
(Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.) ',
        'CORE1', false),
       ('Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?', 'класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать:\n\n
InterfaceB.super.method();', 'CORE1', false),
       ('Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?', '1. Статические блоки от первого до последнего предка(от предка до наследника)\n\n
2. Попарно динамической блок инициализации и конструктор от первого до последнего предка', 'CORE1', false),
       ('Зачем нужны и какие бывают блоки инициализации?', 'Инициализация - это когда мы впервые задаем переменной какое-либо значение.\n\n
Существуют статические и нестатические блоки инициализации.', 'CORE1', false),
       ('Для чего в Java используются статические блоки инициализации?',
        'Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора. Такой блок принадлежит только самому классу.',
        'CORE1', false),
       ('Что произойдет, если в блоке инициализации возникнет исключительная ситуация?', 'Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.\n\n
Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.', 'CORE1', false),
       ('Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?', 'Если возникшее исключение - наследник RuntimeException:\n\n
-для статических блоков инициализации будет выброшено java.lang.ExceptionInInitializerError;\n\n
-для нестатических будет проброшено исключение-источник.\n\n
Если возникшее исключение - наследник Error, то в обоих случаях будет выброшено java.lang.Error.\n\n
Если исключение: java.lang.ThreadDeath - смерть потока. В этом случае никакое исключение выброшено не будет.', 'CORE1',
        false),
       ('Что такое класс Object?', 'Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы\n\n
Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.\n\n',
        'CORE1', true),
       ('Какие методы есть у класса Object (перечислить все)? Что они делают?', '- equals() - проверка на равенство двух обьектов\n\n
- hashCode() - изначально случайно число int\n\n
- toString() - представления данного объекта в виде строки.\n\n
- getClass() - получение типа данного обьекта\n\n
- clone() -  клонирует объект методом.\n\n
- finalize() - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван)\n\n
для многопоточки\n\n
- notify() - «размораживает» одну случайную нить\n\n
- notifyAll() - «размораживает» все нити данного монитора\n\n
- wait() - нить освобождает монитор и «становится на паузу»\n\n
- wait(long timeOut) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах.\n\n
- wait(long timeOut, int nanos) - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.',
        'CORE1', true),
       ('Расскажите про equals и hashcode', '\tХеш-код — это целочисленный результат работы метода, которому в качестве входного параметра передан объект.\n
\tЕсли более точно, то это битовая строка фиксированной длины, полученная из массива произвольной длины. \n
\tEquals - это метод, определенный в Object, который служит для сравнения объектов. При сравнении объектов при помощи == идет сравнение по ссылкам. При сравнении по equals() идет сравнение по состояниям объектов.\n\n
Свойства equals():\n
\t-        Симметричность: Для двух ссылок, a и b, a.equals(b) тогда и только тогда, когда b.equals(a)\n
\t-        Рефлексивность: для любого заданного значения x, выражение x.equals(x) должно возвращать true.\n
\tЗаданного — имеется в виду такого, что x != null\n
\t-        Постоянство: повторный вызов метода equals() должен возвращать одно и тоже значение до тех пор, пока какое-либо значение свойств объекта не будет изменено.\n
\t-        Транзитивность: Если a.equals(b) и b.equals(c), то тогда a.equals(c)\n
\t-        Совместимость с hashCode(): Два тождественно равных объекта должны иметь одно и то же значение hashCode()\n\n
\tПри переопределении equals() обязательно нужно переопределить метод hashCode(). Равные объекты должны возвращать одинаковые хэш коды.',
        'CORE1', true),
       ('Каким образом реализованы методы hashCode() и equals() в классе Object?', '1 - Реализация метода Object.equals() сводится к проверке на равенство двух ссылок:\n\n
public boolean equals(Object obj) {\n
  \treturn (this == obj);\n
}\n\n
2 - HashCode реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым.\n\n
\tРеализация метода Object.hashCode() описана как native, т.е. написана не на Java. Непереопределенный hashCode возвращает идентификационный хеш, основанный на состоянии потока, объединённого с xorshift (в OpenJDK8). А вообще, функция предлагает шесть методов на базе значения переменной hashCode:\n\n
0. Случайно сгенерированное число.\n
1. Функция адреса объекта в памяти.\n
2. Жёстко запрограммированное значение 1 (используется при тестировании на чувствительность (sensitivity testing)).\n
3. Последовательность.\n
4. Адрес объекта в памяти, приведённый к целочисленному значению.\n
5. Состояние потока, объединённое с xorshift (https://en.wikipedia.org/wiki/Xorshift)\n
public native int hashCode();\n\n
\tСитуация, когда у разных объектов одинаковые хеш-коды называется — коллизией. Вероятность возникновения коллизии зависит от используемого алгоритма генерации хеш-кода.',
        'CORE1', true),
       ('Зачем нужен equals(). Чем он отличается от операции ==?',
        'equals() -  сравнение по состоянию, == -  по ссылкам', 'CORE1', false),
       ('Правила переопределения equals()', '1. Проверить на равенство ссылки объектов this и параметра метода o.\n\n
if (this == o) return true;\n\n
2. Проверить, определена ли ссылка o, т. е. является ли она null.\n\n
Если в дальнейшем при сравнении типов объектов будет использоваться оператор instanceof, этот пункт можно пропустить, т. к. этот параметр возвращает false в данном случае null instanceof Object.\n\n
3. Сравнить типы объектов this и o с помощью оператора instanceof или метода getClass(), руководствуясь описанием выше и собственным чутьем.\n\n
4. Если метод equals переопределяется в подклассе, не забудьте сделать вызов super.equals(o)\n\n
5. Выполнить преобразование типа параметра o к требуемому классу.\n\n
6. Выполнить сравнение всех значимых полей объектов:\n\n
  - для примитивных типов (кроме float и double), используя оператор == \n\n
  - для ссылочных полей необходимо вызвать их метод equals\n\n
  - для массивов можно воспользоваться перебором по циклу, либо методом Arrays.equals()\n\n
  - для типов float и double необходимо использовать методы сравнения соответствующих оберточных классов Float.compare() и Double.compare()',
        'CORE1', false),
       ('Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?',
        'Нарушится контракт. Классы и методы, которые использовали правила этого контракта могут некорректно работать. Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.',
        'CORE1', false),
       ('Какой контракт между hashCode() и equals()?', '1) Если два объекта возвращают разные значения hashcode(), то они не могут быть равны\n\n
2) Если equals объектов true, то и хэшкоды должны быть равны. \n\n
3) Переопределив equals, всегда переопределять и hashcode.', 'CORE1', true),
       ('Для чего нужен метод hashCode()?',
        'вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.',
        'CORE1', true),
       ('Правила переопределения метода hashcode()', 'Если хеш-коды разные, то и входные объекты гарантированно разные.\n\n
Если хеш-коды равны, то входные объекты не всегда равны.\n\n
При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.\n\n
- вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.\n\n
- вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).\n\n
- вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.',
        'CORE1', false),
       ('Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?',
        'Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().',
        'CORE1', false),
       ('Могут ли у разных объектов быть одинаковые hashCode()?',
        'Могут. Когда у разных объектов одинаковые хеш-коды называется — коллизией.', 'CORE1', false),
       ('Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?', 'В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено.\n\n
Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть', 'CORE1', false),
       ('Есть класс Point{int x, y;}. Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?',
        'Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.',
        'CORE1', false),
       ('Чем a.getClass().equals(A.class) отличается от a instanceOf A.class',
        'getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком',
        'CORE1', false),
       ('Что такое исключения?',
        'Исключение — это ошибка (является объектом), возникающая во время выполнения программы. ', 'CORE1', true),
       ('Опишите иерархию исключений', '1. класс Throwable (checked)\n\n
2. от Throwable  -> Error (ошибки JVM) и Exception (checked общие)\n\n
3. от Exception \n\n
    - > RuntimeException (unchecked)\n\n
    - > IOException, SQLException, ReflectiveOperationException (checked)\n\n
4.RuntimeException (unchecked):\n\n
  ClassCastExceptiuon\n\n
  IndexOutOfBoundException\n\n
  AritthmeticException\n\n
  NullPointerException\n\n', 'CORE1', true),
       ('Расскажите про обрабатываемые и необрабатываемые исключения', '1. Checked исключения, это те, которые должны обрабатываться блоком catch или описываться в сигнатуре метода. Unchecked могут не обрабатываться и не быть описанными.\n\n
2. Unchecked исключения в Java — наследованные от RuntimeException, checked — от Exception.\n\n
Checked исключения отличаются от Unchecked исключения в Java, тем что \n\n
наличие\обработка Checked исключения проверяются компилятором на этапе компиляции.\n\n
Наличие\обработка Unchecked исключения происходит на этапе выполнения.\n\n', 'CORE1', false),
       ('Можно ли обработать необрабатываемые исключения?',
        'Можно, чтобы в некоторых случаях программа не прекратила работу', 'CORE1', false),
       ('Какой оператор позволяет принудительно выбросить исключение?', 'Throw', 'CORE1', false),
       ('О чем говорит ключевое слово throws?', 'Метод потенциально может выбросить исключение с указанным типом. \n\n
Передаёт обработку исключения вышестоящему методу.', 'CORE1', false),
       ('Как создать собственное («пользовательское») исключение?',
        'Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException) и переопределить методы',
        'CORE1', false),
       ('Расскажите про механизм обработки исключений в java (Try-catch-finally)', 'Try - блок в котором может появиться исключение;\n\n
Catch - блок в котором мы указываем исключение и логику его обработки;\n\n
Finally - блок который обязательно отработает', 'CORE1', false),
       ('Возможно ли использование блока try-finally (без catch)?',
        'try может быть в паре с finally, без catch. Работает это точно так же - после выхода из блока try выполняется блок finally',
        'CORE1', false),
       ('Может ли один блок catch отлавливать сразу несколько исключений?', 'Да', 'CORE1', false),
       ('Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?', 'Да, кроме случаев завершения работы программы или JVM:\n\n
1 - Finally может не выполниться в случае если в блоке try вызывает System.exit(0),\n\n
2 - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.\n\n
3 - В блоке try{} бесконечный цикл.', 'CORE1', true),
       ('Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?', 'Может и оно будет передано в виртуальную машину Java (JVM).\n\n
Для случая с методом main произойдет две вещи:\n\n
- будет завершен главный поток приложения;\n\n
- будет вызван ThreadGroup.uncaughtException.', 'CORE1', false),
       ('В каком порядке следует обрабатывать исключения в catch блоках?', 'От наследника к предку', 'CORE1', false),
       ('Что такое механизм try-with-resources?', 'Дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.\n\n
В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс java.lang.AutoCloseable или java.io.Closeable.\n\n
Closeable extends AutoCloseable', 'CORE1', true),
       ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?',
        'finally-секция может «перебить» throw/return при помощи другого throw/return', 'CORE1', false),
       ('Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?',
        'В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения получившиеся во время закрытия.',
        'CORE1', false),
       ('Что такое сериализация и как она реализована в Java?', 'Сериализация это процесс сохранения состояния объекта в последовательность байт;\n\n
Реализована через интерфейс - маркер Serializable. ', 'CORE1', true),
       ('Для чего нужна сериализация?', 'Для компактного сохранения состояния объекта и считывание этого состояния.',
        'CORE1', false),
       ('Опишите процесс сериализации/десериализации с использованием Serializable.', '1) Класс объекта должен реализовывать интерфейс Serializable\n\n
2) Создать поток ObjectOutputStream (oos), который записывает объект в переданный OutputStream.\n\n
3) Записать в поток: oos.writeObject(Object);\n\n
4) Сделать oos.flush() и oos.close()', 'CORE1', false),
       ('Как изменить стандартное поведение сериализации/десериализации?', 'Использовать интерфейс Externalizable. \n\n
Переопределить методы\n\n
 writeExternal(ObjectOutput out) throws IOException\n\n
 readExternal(ObjectInput in) throws IOException, ClassNotFoundException', 'CORE1', false),
       ('Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?', '1) Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.\n\n
2) Сделать поле static. Значения статических полей автоматически не сохраняются.\n\n
3) Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.',
        'CORE1', false),
       ('Как создать собственный протокол сериализации?', 'Для создания собственного протокола нужно просто переопределить writeExternal() и readExternal().\n\n
В отличие от двух других вариантов сериализации, здесь ничего не делается автоматически. Протокол полностью в ваших руках. ',
        'CORE1', false),
       ('Какая роль поля serialVersionUID в сериализации?', 'Поле private static final long serialVersionUID содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение.\n\n
Если мы не объявляем его явно, Java делает это за нас.', 'CORE1', false),
       ('Когда стоит изменять значение поля serialVersionUID?',
        'Вы должны изменить serialVersionUID только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями , например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.',
        'CORE1', false),
       ('В чем проблема сериализации Singleton?', '- Проблема - в том что после десериализации мы получим другой объект.\n\n
Таким образом, сериализация дает возможность создать Singleton еще раз, что не совсем нужно.\n\n
- Решение - В классе определяется метод с сигнатурой "Object readResolve() throws ObjectStreamException"\n\n
- Назначение  - этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.', 'CORE1', false),
       ('Расскажите про клонирование объектов.', 'в Java, есть 3 способа клонирования объекта:\n\n
1. С использованием интерфейса Cloneable; \n\n
Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод clone() в родительском классе Object является protected, поэтому требуется переопределение его с объявлением как public. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.\n\n
2. С использованием конструктора клонирования объекта;\n\n
В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.\n\n
3. С использованием сериализации.\n\n
Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.', 'CORE1', false),
       ('В чем отличие между поверхностным и глубоким клонированием?', 'Поверхностное копирование копирует настолько малую часть информации, насколько это возможно. По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.\n\n
Глубокое копирование дублирует все. Глубокое копирование — это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции. ',
        'CORE1', false),
       ('Какой способ клонирования предпочтительней?', 'Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:\n\n
Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());\n\n
Поля для клонирования указываются явно;\n\n
Возможность клонировать даже final поля.', 'CORE1', false),
       ('Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?',
        'Метод clone() объявлен в классе Object с сигнатурой native, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты); он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов. ',
        'CORE1', false),
       ('Как создать глубокую копию объекта? (2 способа)', 'Глубокое клонирование требует выполнения следующих правил:\n\n
-Нет необходимости копировать отдельно примитивные данные;\n\n
-Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться super.clone() при переопределении метода clone();\n\n
-Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.\n\n
1 Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс Serializable. Мы сохраняет объект в массив байт и потом прочитать из него.\n\n
2 При помощи библиотеки DeepCloneable\n\n
Глубокое клонирование с этой библиотекой сводится с двум строкам кода:\n\n
Cloner cloner = new Cloner();\n\n
DeepCloneable clone = cloner.deepClone(this);', 'CORE1', false),
       ('Что представляют собой дженерики в Java?', 'Дженерики – это параметризованные типы.\n\n
С их помощью можно объявлять классы, интерфейсы и методы, в которых тип данных указан в виде параметра.\n\n
Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных.\n\n
Эта информация доступна только на этапе компиляции и стирается в runtime, и в байт код попадет только информация о том, что в программе есть некий список List<Object> list вместо List<String> list, например.\n\n
Появились в версии 1.5 ', 'CORE2_COLLECTIONS', false),
       ('Какова цель использования дженериков?', 'Для строгой типизации и проверки на этапе компиляции.\n\n
Дженерики позволяют передавать тип объекта компилятору в форме <тип>. Таким образом, компилятор может выполнить все необходимые действия по проверке типов во время компиляции, обеспечивая безопасность по приведению типов во время выполнения.',
        'CORE2_COLLECTIONS', false),
       ('Что такое сырые типы (raw type)?', 'Сырые типы — это типы без указания типа в фигурных скобках ( List list = new ArrayList<>() ), они использовались до появления дженериков.\n
Не указывая их, под капотом используется Object. ', 'CORE2_COLLECTIONS', false),
       ('Что такое стирание типов?', 'Стирание типов в Java - это процесс удаления информации о типах во время компиляции, позволяющий байт-коду выполняться на разных платформах с различными типами данных. Оно повышает переносимость, улучшает производительность и поддерживает обобщения.
', 'CORE2_COLLECTIONS', false),
       ('Как работают вайлдкарды в контексте дженериков?', 'Маске (wildcard) можно задать ограничения (Преодолеть инвариантность дженериков):\n\n
-“? extends T” (для получения в методе)  - объект, который наследуется от Т, либо сам Т – ковариантность.\n
Если контейнер объявлен ? extends T, то можно только читать значения. В список нельзя ничего добавить, кроме null.\n\n
-“? super T” (для отдачи в методе) - любой объект подтипа Т, включая Т – контравариантность.\n Нельзя прочитать элемент из контейнера с wildcard ? super, кроме объекта класса Object\n\n
При использовании ? мы сообщаем компилятору, чтобы он игнорировал информацию о типе, т.е. <?> - неограниченный символ подстановки. <?> означает то же что и <? extends Object>, т.е. принимает всё. Это можно обойти, создав обобщенный метод, объявленный с переменной типа T.',
        'CORE2_COLLECTIONS', false),
       ('Объясните принцип PECS в контексте дженериков.', 'Producer Extends Consumer Super\n\n
wildcard подстановочный знак:\n
 Если мы объявили wildcard с extends, то это producer. Он только «производит», предоставляет элемент из контейнера, а сам ничего не принимает.\n\n
 Если же мы объявили wildcard с super — то это consumer. Он только принимает, а предоставить ничего не может.\n\n
Иначе говоря:\n
Если вы только получаете объекты из дженерик-коллекции - это producer и надо использвовать extends.\n
Если вы только кладете объекты в коллекцию - это consumer и надо использовать super.\n
Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.', 'CORE2_COLLECTIONS', false),
       ('Что означает термин "коллекция" в Java?',
        'Коллекция – это объект, который содержит набор объектов одного типа. Каждый из этих объектов в коллекции называется элементом.',
        'CORE2_COLLECTIONS', false),
       ('Расскажите про иерархию коллекций в Java.', 'Иерархия коллекций в Java выглядит следующим образом:\n\n
1. Collection (интерфейс)\n
    a. List (интерфейс)\n
        * ArrayList\n
        * LinkedList\n
        * Vector\n
        * ...\n\n
    b. Set (интерфейс)\n
        * HashSet\n
        * TreeSet\n
        * LinkedHashSet\n
        * ...\n\n
    c. Queue (интерфейс)\n
        * PriorityQueue\n
        * ArrayDeque\n
        * ...\n\n
    d. Map (интерфейс)\n
        * HashMap\n
        * TreeMap\n
        * LinkedHashMap\n
        * ...\n\n
Collection - это базовый интерфейс для всех коллекций в Java. Он предоставляет методы для добавления, удаления и поиска элементов.\n\n
List - это упорядоченная коллекция, которая позволяет дубликаты и обеспечивает доступ к элементам по индексу.\n\n
Set - это неупорядоченная коллекция, которая не допускает дубликатов.\n\n
Queue - это упорядоченная коллекция, которая следует принципу FIFO (первым пришел - первым вышел).\n\n
Map - это коллекция пар ключ-значение, которая предоставляет методы для получения значения по ключу.\n\n
Каждая коллекция имеет свои уникальные особенности и области применения. Выбор подходящей коллекции зависит от требований конкретного приложения.',
        'CORE2_COLLECTIONS', true),
       ('Почему Map не является подтипом Collection, в отличие от List и Set?', 'Коллекция (List и Set) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).Map -это совокупность пар "ключ"-"значение".\n\n
У map нет итерабл, не понятно по чему проводить итерацию', 'CORE2_COLLECTIONS', true),
       ('Какие различия между java.util.Collection и java.util.Collections?', 'Класс java.util.Collections содержит исключительно статические методы для работы с коллекциями. \n
В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.\n\n
java.util.Collection - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections.',
        'CORE2_COLLECTIONS', false),
       ('Как отличается итератор с fail-fast итератора с fail-safe поведением? Приведите примеры.', 'Итератор fail-safe не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном.\n
Пример fail-safe - CopyOnWriteArrayList (он создал отдельную копию )и итератор (keySet коллекции ConcurrentHashMap - не создает отдельную копию).\n\n
Итератор fail-fast генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее.\n
Пример fail-fast - Vector и Hashtable.', 'CORE2_COLLECTIONS', false),
       ('В чем разница между Enumeration и Iterator?', 'Iterator имеет больше методов работы с коллекциями и был специально введен в java2, вместо Enumeration(interface). Рекоммендуется юзать Iterator.\n\n
Оба интерфейса предназначены для обхода коллекции, но есть различия:\n
-с помощью Enumeration нельзя удалять элементы;\n
-в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.hasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.next() и т.д);\n
-Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть во всех современных коллекциях.',
        'CORE2_COLLECTIONS', false),
       ('Как связаны между собой интерфейсы Iterable, Iterator и "for-each"?', 'Интерфейс Iterable имеет метод - iterator(), с типом возвращаемого значения - интерфейс Iterator.\n
Экземпляры классов, реализующих интерфейс Iterable, могут использоваться в цикле foreach.', 'CORE2_COLLECTIONS', false),
       ('Можно ли удалить элемент, итерируясь по ArrayList? Какая исключительная ситуация может возникнуть?', 'Можно, но нужно использовать iterator.remove().\n
Иначе при прохождении по ArrayList в цикле for сразу после удаления элемента будет ConcurrentModificationException.',
        'CORE2_COLLECTIONS', false),
       ('Как ведет себя коллекция при использовании метода iterator.remove()?',
        'Этот метод удаляет текущий элемент. Важный момент заключается в том, что сначала этот элемент необходимо получить с помощью метода next(), если мы вызовем метод remove() до метода next(), то мы получим IllegalStateException.',
        'CORE2_COLLECTIONS', false),
       ('Какие существуют реализации интерфейса Map в Java?', '- TreeMap - реализация интерфейса Map, основанная на сбалансированных бинарных деревьях. Это обеспечивает быстрое выполнение операций, связанных с сортировкой элементов в Map.\n\n
- LinkedHashMap - реализация интерфейса Map, которая хранит пары ключ-значение в порядке добавления элементов в Map. Он также может сохранять порядок доступа к элементам.\n\n
- ConcurrentHashMap - это потокобезопасная реализация интерфейса Map, которая позволяет безопасно использовать Map в многопоточном окружении.\n\n
- EnumMap - реализация интерфейса Map, которая использует перечисления в качестве ключей. Она гарантирует, что только определенные значения могут быть использованы в качестве ключей, что делает ее полезной при работе с ограниченным набором ключей.\n\n
- WeakHashMap - реализация интерфейса Map, которая хранит ключи в виде ссылок на объекты. При этом если на объект-ключ больше нет ссылок, то он будет автоматически удален из Map.\n\n
- IdentityHashMap - реализация интерфейса Map, которая использует оператор "==" для сравнения ключей вместо метода equals(). Он может быть полезен при работе с ключами, которые могут иметь одинаковое значение, но различные ссылки.',
        'CORE2_COLLECTIONS', false),
       ('Как устроена HashMap, и какова сложность ее основных операций (до Java 8 и после)? Объясните принцип корзин.', 'HashMap – внутри состоит из корзин и списка элементов, на которые ссылаются корзины.\n
Корзины – массив\n\n
Элементы(Node) – связанный список ( Принцип связи в корзинах основан на linkedlist), то есть каждый элемент списка имеет указатель на следующий элемент. Перавая идет проверка на null\n\n
При добавлении нового элемента, хэш-код ключа определяет корзину для элемента с помощью hashFunction(), который принимает hashCode ключа и возвращает номер корзины. В корзине есть ссылка на связанный список, в который будет положен наш объект. Идет проверка, есть ли элементы в этом списке. Если нету, то корзина получает ссылку нового элемента, если есть, то происходит прохождение по списку элементов и сравнивание элементов в списке. Проверяется равенство hashcode. Зная о коллизии, проводится еще сравнивание ключей методом equals.\n\n
Если оба равны: идет перезапись\n
Если не равен equals: добавляется элемент в конец списка\n\n
HashMap имеет поле loadFactor. Оно может быть задано через конструктор. По умолчанию - 0.75. Его произведение на количество корзин дает нам необходимое число объектов которое нужно добавить чтобы состоялось удвоение количества корзин.\n\n
Например если у нас мапка с 16-ю(default) корзинами, а loadFactor равняется 0.75, то расширение произойдет когда мы добавим 16 * 0.75 = 12 объектов.\n\n
После удвоения все объекты будут перераспределены с учетом нового количества корзин\n
Если индексы равны хэщ-коды равный ключи равны то происходит перезапись элемента\n
Метод get()  - проверка по хэш коду после проверка на equals\n
При коллизии и хранении в 1 бакете огромного LinkedList скорость будет О(n) до Java 8 после в сбаласированное красно-черное дерево и скокрость O(log2(n))',
        'CORE2_COLLECTIONS', true),
       ('Как устроена TreeMap, и какова сложность ее основных операций?',
        'Класс TreeMap<K, V> представляет отображение в виде дерева.\n Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap.\n Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.\n Если ключи одинаковые то происходит перезапись.\n Treemap - не сонхронизированная коллекция. Возможность работы с null-ключом - Можно, если используется компаратор, разрешающий null',
        'CORE2_COLLECTIONS', false),
       ('Как ведет себя HashMap, если пытаться добавить в нее два элемента с одинаковыми hashCode(), но с различающимися equals()?',
        'По значению hashCode() вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен.\n Перед добавлением осуществляется проверка на наличие элементов в этой ячейке.\n Если элементы с таким hashCode() уже присутствует, но их equals() методы не равны, то элемент будет добавлен в конец списка.',
        'CORE2_COLLECTIONS', true),
       ('Как поведет себя HashMap, если ключ, у которого определены некорректно equals и hashCode, будет добавлен?',
        'Объект скорее всего добавится, но обратно мы не сможем получить его.', 'CORE2_COLLECTIONS', true),
       ('Возможно ли, что HashMap превратится в список, даже если ключи имеют разные hashCode()?',
        'Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.',
        'CORE2_COLLECTIONS', true),
       ('Почему нельзя использовать byte[] в качестве ключа в HashMap?',
        'Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива).\n\n Также у массивов не переопределен equals и выполняется сравнение указателей.\n Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.',
        'CORE2_COLLECTIONS', true),
       ('Сможет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?',
        'Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.',
        'CORE2_COLLECTIONS', true),
       ('Каково худшее время выполнения метода get(key) для ключа, отсутствующего в HashMap?',
        'O(N). Худший случай - это поиск ключа в таблице, вырожденной в список, перебор ключей которой занимает линейно пропорциональное время количеству хранимых элементов.',
        'CORE2_COLLECTIONS', true),
       ('Каково худшее время выполнения метода get(key) для ключа, присутствующего в HashMap?', 'O(N) - линейное',
        'CORE2_COLLECTIONS', true),
       ('Что такое rehashing?', 'Rehashing в Java - это процесс изменения размера хэш-таблицы и перераспределения ее элементов для повышения производительности и предотвращения коллизий.\n\n
Когда хэш-таблица становится слишком заполненной, производительность поиска и вставки снижается. Rehashing решает эту проблему путем создания новой хэш-таблицы большего размера и перераспределения всех существующих элементов в новую таблицу.\n\n
В Java rehashing выполняется автоматически, когда заполняемость хэш-таблицы превышает определенный порог (по умолчанию 0,75). Во время rehashing все элементы удаляются из старой таблицы, хэш-функция применяется к каждому элементу для получения нового индекса, и элементы вставляются в новую таблицу с этим индексом.\n\n
Rehashing является важной операцией для поддержания производительности хэш-таблиц и предотвращения деградации производительности из-за коллизий.',
        'CORE2_COLLECTIONS', true),
       ('При каких условиях список в бакете перерождается в красно-черное дерево?',
        'Список в бакете перерождается в красно-черное дерево в Java, когда количество элементов в бакете превышает определенный порог (по умолчанию 8).',
        'CORE2_COLLECTIONS', true),
       ('Как Set отличается от Map?', 'Основные отличия:\n\n
* Уникальность: Set хранит только уникальные элементы, в то время как Map допускает дубликаты ключей.\n\n
* Порядок: Set неупорядочен, а Map не гарантирует порядка итерации по парам ключ-значение.\n\n
* Значения: Set хранит только сами элементы, в то время как Map хранит пары ключ-значение, где значение может быть любого типа.\n\n
* Поиск: Поиск элемента в Set осуществляется по его значению, в то время как в Map поиск осуществляется по ключу.\n\n
В целом, Set используется для хранения набора уникальных элементов, а Map используется для хранения данных в виде пар ключ-значение, где ключ служит для идентификации соответствующего значения.',
        'CORE2_COLLECTIONS', false),
       ('Как Set отличается от List?', 'Set не добавляет новых методов, только вносит изменения в унаследованные.\n\n
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.\n\n
Разрешено наличие только одной ссылки типа null. Set не имеет дубликатов List имеет', 'CORE2_COLLECTIONS', false),
       ('Объясните интерфейс Set в Java.', 'Интерфейс Set расширяет интерфейс Collection. \n\n
Set не добавляет новых методов, только вносит изменения унаследованные.\n\n
Set - неупорядоченный набор неповторяющихся элементов\n\n
В частности, метод add() добавляет элемент в коллекцию и возвращает true, если не было такого элемента.\n\n
Разрешено наличие только одной ссылки типа null.', 'CORE2_COLLECTIONS', false),
       ('Расскажите о реализациях интерфейса Set.', 'В HashSet порядок добавления элементов будет непредсказуемым - используется хэширование для ускорения выборки.\n\n
В TreeSet объекты хранятся отсортированными по возрастанию из-за применения к/ч дерева.\n\n
LinkedHashSet хранит элементы в порядке добавления.', 'CORE2_COLLECTIONS', false),
       ('Каковы отличия между TreeSet и HashSet?', 'HashSet быстрее, чем TreeSet .\n\n
В HashSet элементы в случайном порядке, в TreeSet в отсортированном.\n\n
HashSet обеспечивает постоянную производительность - О(1) - для большинства операций, таких как add () , remove () и contains () , по сравнению с временем log(n), предлагаемым TreeSet.',
        'CORE2_COLLECTIONS', false),
       ('В чем разница между LinkedHashSet и HashSet?',
        'Основное различие в том, что LinkedHashSet сохраняет порядок вставки элементов, а HashSet - нет.\n В основе LinkedHashSet лежит LinkedHashMap вместо HashMap. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов',
        'CORE2_COLLECTIONS', false),
       ('Как изменится TreeSet, если добавлять элементы в него по возрастанию?',
        'TreeSet все равно в каком порядке вы добавляете в него элементы, так как в основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать и хранить элементы по возрастанию. ',
        'CORE2_COLLECTIONS', false),
       ('Как устроен HashSet, и какова сложность его основных операций? Объясните принцип корзин.', 'HashSet в Java представляет собой коллекцию, которая хранит уникальные элементы и не допускает дублирования значений. Он основан на принципе хэширования, где каждый элемент добавляется в хэш-таблицу под уникальным индексом.\n\n
Принцип корзин (Bucket Principle) заключается в том, что элементы в HashSet хранятся в массиве (или массивах) под некоторыми индексами, которые обычно вычисляются с использованием хеш-функции. Если два или более элемента имеют одинаковый хеш-код, то они будут храниться в одной и той же "корзине", то есть в одном и том же массиве. При этом, внутри "корзины" может быть использована другая структура данных (например, связанный список), чтобы хранить коллизии - случаи, когда разные элементы имеют одинаковый хеш-код.\n\n
Основные операции HashSet и их сложность:\n
- add(element) - добавление элемента: O(1) (в среднем)\n
- contains(element) - проверка наличия элемента: O(1) (в среднем)\n
- remove(element) - удаление элемента: O(1) (в среднем)', 'CORE2_COLLECTIONS', false),
       ('Как устроен LinkedHashSet, и какова сложность его основных операций?', 'LinkedHashSet в Java является комбинацией HashSet и LinkedHashMap. Он представляет собой коллекцию, которая хранит уникальные элементы, сохраняя порядок вставки. LinkedHashSet использует хэш-таблицу для хранения уникальных элементов и двусвязанный список для сохранения порядка вставки.\n\n Основные операции LinkedHashSet и их сложность:\n
- add(element) - добавление элемента: O(1) (в среднем)\n
- contains(element) - проверка наличия элемента: O(1) (в среднем)\n
- remove(element) - удаление элемента: O(1) (в среднем)', 'CORE2_COLLECTIONS', false),
       ('Как устроен TreeSet, и какова сложность его основных операций?', 'TreeSet в Java представляет собой коллекцию элементов, отсортированных в соответствии с их значением. Внутри TreeSet используется красно-черное дерево (Red-Black Tree) для хранения элементов. Каждый узел дерева содержит ссылки на левого и правого потомков, а также указатель на родителя, значение элемента, и цвет узла.\n\n
Сложность основных операций в TreeSet:\n
1. Добавление элемента в TreeSet (add): O(log n).\n
2. Удаление элемента из TreeSet (remove): O(log n).\n
3. Поиск элемента в TreeSet (contains): O(log n)', 'CORE2_COLLECTIONS', false),
       ('Объясните интерфейс List в Java.',
        'Контейнеры List хранит элементы в порядке добавления.\n Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.\n Позволяет хранить дубликаты и null.\n Каждый элемент имеет индекс.\n Это позволяет получить (get) элемент по индексу или задать значением для определённого индекса (set).\n Методы коллекций add, addAll, remove позволяют указать индекс, с которого необходимо их выполнять.\n Кроме того, у List есть своя версия итератора, которая называется ListIterator.\n Этот итератор знает про индекс элемента, поэтому он умеет итерироваться не только вперёд, но и назад.\n Его даже можно создать от определённого места в коллекции.\n Скорость LinkedList - O(n)\n LinkedList — это связанный (Linked) список (List).\n Каждая запись в связанном списке представлена в виде Entry, которая хранит сами данные, а так же ссылку на следующую (next) и предыдущую (previous) Entry.\n Таким образом LinkedList реализует "Последовательный доступ" (Sequential Access).',
        'CORE2_COLLECTIONS', false),
       ('Как устроен ArrayList, и какова сложность его основных операций?', 'ArrayList хранит элементы в динамическом массиве. Элементы ArrayList могут быть абсолютно любых типов в том числе и null.\n\n
**Основное преимущество** такой коллекции над массивом – это **расширяемость** – увеличение длины при надобности.\n\n
Если в этом массиве заканчивается место, то создаётся второй массив побольше, куда копируются все элементы из первого.\n\n
При добавлении элемента в середину ArrayList, все элементы справа от него копируются на 1 позицию вправо, а затем в пустую ячейку добавляется новый элемент.\n\n
По возможности, избегайте операций вставки в середину коллекции. Ведь системе приходится заново пересчитывать индексы элементов.\n\n
При удалении элемента из середины, все элементы справа от него копируются на 1 позицию влево. Сам массив не укорачивается (можно укоротить через trimToSize()).\n\n
Особенности\n
- Быстрый доступ к элементам по индексу за время O(1);\n
- Доступ к элементам по значению за линейное время O(n);\n
- Медленный, когда вставляются и удаляются элементы из «середины» списка;\n
- Позволяет хранить любые значения в том числе и null;\n
- Не синхронизирован.', 'CORE2_COLLECTIONS', true),
       ('Что лучше использовать ArrayList или LinkedList?',
        'ArrayList подходит для работы с коллекцией, доступной только для чтения, а LinkedList подходит для работы с коллекцией, допускающей различные модификации данных, такие как добавление и удаление.',
        'CORE2_COLLECTIONS', true),
       ('Оцените объем памяти, необходимый для хранения одного примитива типа byte в LinkedList.', 'в x32 JVM около 32 байтов выделяется для хранения одного значения типа byte в LinkedList.\n
Для 64-битной JVM каждая ссылка занимает 64 бита (8 байт).', 'CORE2_COLLECTIONS', false),
       ('Оцените объем памяти, необходимый для хранения одного примитива типа byte в ArrayList.', 'ArrayList основан на массиве. Каждый элемент массива хранит примитивный тип данных - byte, размер которого 1 байт.
 ', 'CORE2_COLLECTIONS', false),
       ('Что такое Queue в Java?', 'Очереди представляют структуру данных, работающую по принципу FIFO (first in - first out).\n\n
У всех классов, которые реализуют данный интерфейс, будет метод `offer` для добавления в очередь, метод `poll` для извлечения элемента из головы очереди, и методы `peek` и `element`, позволяющие просто получить элемент из головы очереди.',
        'CORE2_COLLECTIONS', false),
       ('Что представляет собой Deque, и в чем разница между Deque и Queue?', 'представляет собой двухстороннюю очередь, которая может использоваться как стек или очередь. Другими словами, вы можете добавлять и удалять элементы как с начала, так и с конца очереди. Эта структура данных поддерживает все операции, которые поддерживает Queue, а также операции добавления/удаления элементов в/из начала и конца очереди: addFirst(), addLast(), removeFirst(), removeLast(), getFirst() и getLast().\n\n
Таким образом, основным отличием между Queue и Deque является то, что Deque предоставляет более широкий набор операций, позволяющих добавлять и удалять элементы как в начале, так и в конце очереди. В то же время, Queue ориентирована на работу только со структурой данных, работающей по принципу FIFO, тогда как Deque может использоваться для реализации как стека, так и очереди.',
        'CORE2_COLLECTIONS', false),
       ('Приведите пример реализации Deque в Java.', 'ArrayDeque. Также один из примеров реализации - это Линкед лист.',
        'CORE2_COLLECTIONS', false),
       ('Какую коллекцию можно использовать для реализации FIFO?', 'Queue (PriorityQueue)', 'CORE2_COLLECTIONS', false),
       ('Какую коллекцию можно использовать для реализации LIFO?', 'Stack, ArrayDeque', 'CORE2_COLLECTIONS', false),
       ('Начальная емкость коллекций?', '- ArrayList - 10 элементов.** Новая емкость рассчитывается как (старая емкость * 3) / 2 + 1.\n\n - LinkedList - 0\n\n
- HashMap, HashSet, LinkedHashSet, TreeSet, ArrayDeque - 16 элементов. Коэффициент загрузки 0.75\n
- PriorityQueue - 11 элементов. Коэффициент загрузки 0.75', 'CORE2_COLLECTIONS', true),
       ('Что такое функциональный интерфейс, и как он используется в Java?', 'Это интерфейс, который содержит только 1 абстрактный метод.\n
Интерфейс может включать сколько угодно default (и static) методов и при этом оставаться функциональным, потому что default методы - не абстрактные.',
        'CORE2_COLLECTIONS', false),
       ('Для чего предназначена аннотация @FunctionalInterface?',
        'Аннотация @FunctionalInterface в Java используется для обозначения интерфейса, который имеет только один абстрактный метод. Это позволяет компилятору проверять, что интерфейс действительно является функциональным интерфейсом, и генерировать более эффективный байт-код для лямбда-выражений и ссылок на методы, реализующих этот интерфейс.',
        'CORE2_COLLECTIONS', false),
       ('Какие встроенные функциональные интерфейсы вы знаете?', 'Predicate<T> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе значение типа boolean\n\n
Consumer<T> - реализуется функция, которая получает на вход экземпляр класса T, производит с ним некоторое действие и ничего не возвращает\n\n
Function<T,R> - реализуется функция, получающая на вход экземпляр класса T и возвращающая на выходе экземпляр класса R\n\n
Supplier<T> - реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса T\n\n
UnaryOperator<T> - принимает в качестве параметра объект типа T, выполняет над ними операции и возвращает результат операций в виде объекта типа T\n\n
BinaryOperator<T, Т> - реализуется функция, получающая на вход два экземпляра класса T и возвращающая на выходе экземпляр класса T',
        'CORE2_COLLECTIONS', false),
       ('Что такое ссылка на метод в контексте лямбда-выражений?', 'Ссылка на статический метод - имя_класса::имя_метода\n\n
Ссылка на нестатический метод конкретного объекта - имя_экземпляра::имя_методаимя_класса::имя_метода\n\n
Ссылка на конструктор - ClassName::new\n\n
Ссылка на метод - это сокращенный синтаксис выражения лямбда, который выполняет только один метод. Это позволяет нам ссылаться на конструкторы или методы, не выполняя их. ',
        'CORE2_COLLECTIONS', false),
       ('Что представляет собой лямбда-выражение, и чем его можно заменить?',
        'Лямбда-выражение — это анонимная функция в программировании, которая может быть использована вместо объявления и вызова отдельной функции. Оно представляет собой короткую запись для определения функции без необходимости объявления ее имени и типа',
        'CORE2_COLLECTIONS', false),
       ('Что такое Stream API, и для чего используются стримы?', 'Stream API — это новый способ работать со структурами данных в функциональном стиле. Stream (поток) API (описание способов, которыми одна компьютерная программа может взаимодействовать с другой программой) — это по своей сути поток данных\n\n
С появлением Java 8 Stream API позволило программистам писать существенно короче то, что раньше занимало много строк кода, а именно — упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными. Если у вас промежуточных операций нет, часто можно и нужно обойтись без стрима, иначе код будет сложнее чем без потока.',
        'CORE2_COLLECTIONS', false),
       ('Почему Stream называется ленивым?',
        'Из-за того, что пока не будет вызвана последняя операция над стримом, с ним не будет происходить никаких действий. Т.е. промежуточные операции выполняются лениво.',
        'CORE2_COLLECTIONS', false),
       ('Какие способы создания стрима вы знаете?', '1. Из массива Arrays.stream()\n
2. Из набора значений Stream.of()\n
3. Из файла File.lines()\n
4. Из коллекции "collection".stream()\n
5. Из строки "string".chars()\n
6. С помощью Stream.builder()\n
7. С помощью Stream.iterate(оператор) (бесконечный)\n
8. С помощью Stream.generate(саплаер) (бесконечный)', 'CORE2_COLLECTIONS', false),
       ('Как можно создать стрим из коллекции?', 'Вызвать метод stream()', 'CORE2_COLLECTIONS', false),
       ('Какие промежуточные операции со стримами вы знаете?', '1. filter - фильтрует записи и возвращает только соответствующие условию\n
2. skip - пропускает определенное кол-во первых элементов\n
3. distinct - удаляет дубликаты элементов\n
4. map - преобразует каждый элемент стрима\n
5. peek - возвращает тот же стрим, но применяет функцию к каждому элементу стрима\n
6. limit - ограничивает стрим кол-вом первых элементов\n
7. sorted - сортирует значения в натуральном порядке или по компоратору\n
8. mapToInt/Long/double - возвращает стрим из числовых примитивов\n
9. flatMap (ToInt..) - создает из одного элемента несколько\n
10. mapToObj - переводит числовой стрим в объектный', 'CORE2_COLLECTIONS', true),
       ('В чем разница между методами map() и flatMap() в стримах?',
        'Тем что map() применяет функцию к каждому элементу, а flatMap() разбивает каждый элемент на стримы (от 0 до бесконечности) и затем объединяет их',
        'CORE2_COLLECTIONS', false),
       ('Какие терминальные операции со стримами вы знаете?', '1. findAny - возвращает любой подходящий элемент;\n
2. findFirst - возвращает первый элемент;\n
3. collect - позволяет вернуть результат в виде структуры данных (коллекции);\n
4. count - возвращает число элементов;\n
5. anyMatch - возвращает true в случае выполнения условия для хотя бы одного элемента\n
6. noneMatch - возвращает true в случае невыполнения условия для каждого элемента\n
7. allMatch - возвращает true в случае выполнения условия для каждого элемента\n
8. min - минимальный элемент по компоратору;\n
9. max - максимальный элемент по компоратору;\n
10. forEach - применяет функцию к каждому элементу, порядок не гарантирован;\n
11. forEachOrdered - применяет функцию к каждому элементу с гарантированным порядком\n
12. toArray - возвращает массив значений\n
13. reduce - выполняет агрегатные функции и возвращает один результат\n
14. sum - сумма всех чисел (только для числовых стримов)\n
15. avarage - среднее арифметическое (только для числовых стримов)', 'CORE2_COLLECTIONS', true),
       ('Объясните метод collect() в контексте стримов.',
        'Позволяет получить результат в виде коллекции, принимает на вход коллектор.', 'CORE2_COLLECTIONS', false),
       ('Объясните метод reduce() в контексте стримов.', 'позволяет выполнять агрегатные функции и возвращать один результат.\n
Результат применения бинарного оператора к каждой паре элементов стрима, пока не останется один элемент.\n
Позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат', 'CORE2_COLLECTIONS', false),
       ('Расскажите о классе Collectors и его методах в контексте стримов.', 'Нужен для того, чтобы упаковывать стримы в коллекции:\n
toList() - преобразует поток в список — List<T>\n
toSet() - преобразует поток в список — Set<T>\n
toMap() - преобразует поток в список — Map<K, V>\n
Используются в методе collect().', 'CORE2_COLLECTIONS', false),
       ('Что такое параллельная обработка в Java 8?', 'Чтобы сделать обычный последовательный поток параллельным, надо вызвать у объекта Stream метод parallel(внутри потока). А обратный метод - sequential(). Кроме того, можно также использовать блокирующий метод parallelStream() интерфейса Collection для создания параллельного потока из коллекции. В то же время если рабочая машина не является многоядерной, то поток будет выполняться как последовательный.\n\n
Работает на фреймворке fork/join(под капотом).Кроме того, можно также использовать метод parallelStream() (над стримами потока) интерфейса Collection для создания параллельного потока из коллекции. - сразу создается параллельнй стрим',
        'CORE2_COLLECTIONS', false),
       ('Что представляют собой IntStream и DoubleStream?', 'В Java 8 создание Stream-ов примитивов напрямую невозможно, из-за дженериков. Но разработчики сделали 3 Stream-а примитивов : IntStream, LongStream, DoubleStream. Работает быстрее, чем стрим с классами-обертками.\n
Поддерживают дополнительные терминальный методы sum(), average(), mapToObj()', 'CORE2_COLLECTIONS', false),
       ('Какие нововведения появились в Java 8?', '1. Полноценная поддержка лямбда-вражений\n
2. Ссылки на методы :: \n
3. Функциональные интерфейсы\n
4. default методы в интефейсах\n
5. Потоки для работы с коллекциями\n
6. Новое api для работы с датами \n
7. Nashorn движок JavaScript, разрабатываемый полностью на Java компанией Oracle.\n
8. Кодировщик/декодировщик.\n
9. Новые методы для Map - PutIfAbsent(), СomputeIfAbsent()\СomputeIfPresent(), Remove(), GetOrDefault(), Merge()\n
10. Metaspace пришла на замену PermGen', 'CORE2_COLLECTIONS', false),
       ('Какие новые классы для работы с датами появились в Java 8?',
        'LocalDate , LocalTime, LocalDateTime, ZonedDateTime, Period, Duration', 'CORE2_COLLECTIONS', false),
       ('Что представляет собой класс Optional в Java?',
        'Optional - новый класс в пакете java.util, является контейнером (оберткой) для значений которая также может безопасно содержать null.\n Благодаря опциональным типам можно забыть про проверки на null и NullPointerException.',
        'CORE2_COLLECTIONS', false),
       ('Какой класс появился в Java 8 для кодирования и декодирования данных?',
        'public static class Base64.Encoder /public static class Base64.Decoder', 'CORE2_COLLECTIONS', false),
       ('Как создать кодировщик и декодировщик Base64 в Java?', 'Используя метод getDecoder() класса Base64 он возвращает декодировщик Base64.Decoder, который декодирует данные с помощью схемы кодирования base64.\n
Используя метод getEncoder() класса Base64 он возвращает кодировщик Base64.Encoder, который кодирует данные с помощью схемы кодирования base64.',
        'CORE2_COLLECTIONS', false),
       ('Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8?', '1. forEach() — позволяет выполнять заданное действие для каждой пары ключ-значение в мапе.\n
2. replace(key, oldValue, newValue) — заменяет значение oldValue на newValue для заданного ключа key, только если oldValue соответствует текущему значению ключа.\n
3. replaceAll() — заменяет каждое значение в мапе, используя определённую функцию.\n
4. compute() — позволяет вычислить новое значение для заданного ключа и заменить старое значение новым вычисленным значением.\n
5. computeIfAbsent() — позволяет вычислить новое значение для заданного ключа, только если заданный ключ отсутствует в мапе.\n
6. computeIfPresent() — позволяет вычислить новое значение для заданного ключа, только если заданный ключ присутствует в мапе.\n
7. merge() — выполняет объединение двух мап с определённой функцией, когда ключ встречается в двух мапах.',
        'CORE2_COLLECTIONS', false),
       ('Что такое LocalDateTime в контексте дат и времени?',
        'LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу. Время хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.',
        'CORE2_COLLECTIONS', false),
       ('Что представляет собой ZonedDateTime в контексте дат и времени?',
        'java.time.ZonedDateTime — аналог java.util.Calendar, класс с самым полным объемом информации о временном контексте в календарной системе ISO-8601. Включает объект ZoneId - временную зону(в ZoneId 599 зон), поэтому все операции с временными сдвигами этот класс проводит с её учётом.',
        'CORE2_COLLECTIONS', false),
       ('Что такое Instant?', 'Вместо часов, минут и секунд, он оперирует секундами, миллисекундами и наносекундами.\n\n
Этот класс хранит в себе два поля:\n
- количество секунд, прошедшее с 1 января 1970 года\n
- количество наносекунд\n\n
Класс считает время в Unix-time: от начала 1970 года.\n
Можно даже сказать, что класс Instant — это упрощенная версия класса Date: оставили только то, что нужно программистам.',
        'CORE2_COLLECTIONS', false),
       ('В чем отличие Instant от LocalDateTime?', 'Instant — это мгновенная точка на временной шкале. Она представляет собой момент времени, который не зависит от часового пояса. Instant измеряется в наносекундах от начала эпохи Unix (1970-01-01T00:00:00Z). Это обычно используется в технических целях, например, для метки времени при трассировке событий или измерении продолжительности событий.\n\n
LocalDateTime - это комбинация даты и времени без информации о часовом поясе. Он представляет собой дату и время с точностью до наносекунд, но без учета часового пояса. Это обычно используется для представления даты и времени в человеко-читаемом формате.\n\n
Таким образом, при выборе между Instant и LocalDateTime, следует обратить внимание на следующие моменты:\n
Если в приложении требуется работать с метками времени и измерять время с высокой точностью, то лучше использовать Instant.\n
Если же в приложении требуется работать с датами и временем в формате, удобном для человека, и часовой пояс не важен, то подойдет LocalDateTime.',
        'CORE2_COLLECTIONS', false),
       ('Чем отличается процесс от потока?',
        'Процесс - это экземпляр выполняющейся программы, простыми словами при запуске любой программы на вашем компьютере, вы порождаете процесс. Он имеет свое собственное адресное пространство памяти и один или несколько потоков.\n\n Поток - это последовательность инструкций, выполняющаяся внутри процесса.',
        'CORE3_MULTITHREADING', false),
       ('В чем разница между классом Thread и интерфейсом Runnable? В каких случаях предпочтительно использовать Thread, а в каких Runnable?',
        'Thread - это класс, некоторая надстройка над физическим потоком.\n\n Runnable - это интерфейс, представляющий абстракцию над выполняемой задачей.\n\n Помимо того, что Runnable помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.\n\n В классе Thread имеется несколько методов, которые можно переопределить в порожденном классе. Из них обязательному переопределению подлежит только метод run(). Этот же метод, безусловно, должен быть определен и при реализации интерфейса Runnable.\n\n Некоторые программисты считают, что создавать подкласс, порожденный от класса Thread, следует только в том случае, если нужно дополнить его новыми функциями.\n\n Так, если переопределять любые другие методы из класса Thread не нужно, то можно ограничиться только реализацией интерфейса Runnable.\n Кроме того, реализация интерфейса Runnable позволяет создаваемому потоку наследовать класс, отличающийся от Thread',
        'CORE3_MULTITHREADING', false),
       ('Что представляет собой монитор? Как в Java реализован монитор?', '\tВ Java у каждого класса и объекта есть привязанный к нему монитор. Монитор - механизм синхронизации потоков, обеспечивающий доступ к неразделяемым ресурсам. Частью монитора является mutex, который встроен в класс Object и имеется у каждого объекта.\n
\tУдобно представлять mutex как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.\n
\tВ Java монитор реализован с помощью ключевого слова synchronized.', 'CORE3_MULTITHREADING', true),
       ('Что такое синхронизация? Какие методы синхронизации существуют в Java?', 'Синхронизация это процесс, который позволяет выполнять потоки параллельно.\n\n
В Java все объекты имеют блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте. Такая синхронизация помогает предотвратить повреждение состояния объекта.\n\n
Способы синхронизации в Java:\n\n
Системная синхронизация с использованием wait()/notify().\n
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод wait(), предварительно захватив его монитор. На этом его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод notify() (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, потому как методы wait()/notify() не синхронизированы!\n\n
Системная синхронизация с использованием join().\n
Метод join(), вызванный у экземпляра класса Thread, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.\n\n
Использование классов из пакета java.util.concurrent.Locks - механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.',
        'CORE3_MULTITHREADING', true),
       ('Какое значение имеет ключевое слово synchronized? Где и для каких целей его следует использовать?', 'Зарезервированное слово позволяет добиваться синхронизации в помеченных им методах или блоках кода.\n\n Synchronized – лочит доступ к выполнению метода «условно» для всех потоков кроме 1, как 1 закончит работу может приступить 2 для этого метода. Переменные и конструкторы не могут быть Synchronized\n\n
Блокировка любая идет на классе или объекте а не на коде т.к синхронизируемся с помощью монитора на каком либо объекте или классе\n\n
Synchronized(this) – помогает пометить блок кода в методе чтобы не помечать весь метод\n\n
Synchronized блоки используем только тогда когда нужно избежать Data Race (гонка). Статик методы синхронизируются не по методу а по классу',
        'CORE3_MULTITHREADING', false),
       ('Какой объект является монитором для статического synchronized-метода?',
        'Объект типа Class, соответствующий классу, в котором определен метод.', 'CORE3_MULTITHREADING', false),
       ('Какой объект является монитором для нестатического synchronized-метода?', 'Объект this',
        'CORE3_MULTITHREADING', false),
       ('Как действуют методы wait(), notify() и notifyAll() в контексте многопоточности?', 'wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();\n\n
notify(): Не освобождает монитор и будит поток у которого ранее был вызван метод waiit();\n\n
notifyAll(): Не освобождает монитор и будит все потоки у которых ранее был выван метод  waiit();\n\n
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting). Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным. Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable). Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.\n\n
wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.', 'CORE3_MULTITHREADING', false),
       ('В каких состояниях может находиться поток?', 'New - объект класса Thread создан, но еще не запущен. Он еще не является потоком выполнения и естественно не выполняется.\n
Runnable - поток готов к выполнению, но планировщик еще не выбрал его.\n
Running – поток выполняется.\n
Waiting/blocked/sleeping - поток блокирован или поток ждет окончания работы другого потока.\n
Dead - поток завершен. Будет выброшено исключение при попытке вызвать метод start() для dead потока.\n
 public enum State (У класса Thread есть внутренний класс State - состояние, а также метод public State getState().)\n
{\n
 NEW, — поток создан, но еще не запущен;\n
 RUNNABLE, — поток выполняется;\n
 BLOCKED, — поток блокирован;\n
 WAITING, — поток ждет окончания работы другого потока;\n
 TIMED_WAITING, — поток некоторое время ждет окончания другого потока;\n
 TERMINATED; — поток завершен.\n
}', 'CORE3_MULTITHREADING', false),
       ('Что такое семафор? Как его можно реализовать в Java?',
        'Semaphore – это синхронизатор позволяющий ограничить доступ к каждому ресурсу .В конструктор Симофор нужна передавать количество потоков, которым Симофор будет разрешать одновременно использовать этот ресурс. Доступ управляется с помощью счётчика: изначальное значение счетчика задается в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счетчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счетчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока.\n\n Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.',
        'CORE3_MULTITHREADING', false),
       ('Какое значение имеет ключевое слово volatile? Почему операции с volatile переменными не являются атомарными?', 'Volatile - используется для пометки переменной как хранящейся только в основной памяти Main Memory(куча) !!!\n\n ИСПОЛЬЗУЕТСЯ ТОЛЬКО ТОГДА КОГДА ТОЛЬКО ОДИН ПОТОК МОЖЕТ ИЗМЕНЯТЬ ЗНАЧЕНИЕ ПЕРМЕННОЙ А ОСТАЛЬНЫЕ ПОТОКИ МОГУТ ЕЕ ТОЛЬКО ЧИТАТЬ!!!\n\n Переменная volatile является атомарной для чтения, но операции над переменной НЕ являются атомарными.\n\n Поля, для которых неприемлемо увидеть «несвежее» (stale) значение в результате кэширования или переупорядочения.\n\n
Если происходит какая-то операция, например, инкримент, то атомарность уже не обеспечивается, потому что сначала выполняется чтение(1), потом изменение(2) в локальной памяти, а затем запись(3).\n Такая операция не является атомарной и в неё может вклиниться поток по середине.\n\n
Атомарная операция выглядит единой и неделимой командой процессора.\n\n
Переменная volatile находится в хипе, а не в кэше стека . ', 'CORE3_MULTITHREADING', false),
       ('Зачем нужны атомарные (Atomic) типы данных? В чем отличие от переменных с ключевым словом volatile?',
        'volatile не гарантирует атомарность.\n Например, операция count++ не станет атомарной просто потому что count объявлена volatile.\n C другой стороны class AtomicInteger предоставляет атомарный метод для выполнения таких комплексных операций атомарно над int,\n – Atomic - это семейство классов из java.util.concurrent.\n Они предоставляют набор атомарных операций для соответствующих типов.\n Например с помощью методов getAndIncrement/incrementAndGet класса AtomicInteger можно делать неатомарный в обычных условиях инкремент (i++).',
        'CORE3_MULTITHREADING', true),
       ('Что представляют собой демон-потоки? Какова их роль и как создать демон-поток?', 'Потоки Демоны - потоки предназначены для выполнения фоновых задач и оказания различных сервисов USER потокам ( При завершении работы последнего USER потока программа завершает свое выполнеие не дожидаясь оконачание работы Демон потоков).\n\n Такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска.\n Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет.\n Основной поток приложения может завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания, что поток-демон еще работает.\n\n
Поток демон можно сделать только если он еще не запущен. Пример демона - GC.', 'CORE3_MULTITHREADING', false),
       ('Что такое приоритет потока? Как он влияет на выполнение потока? Какой приоритет у потоков по умолчанию?', 'Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета(является ли поток демоном).\n\n
Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level). Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10. Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.\n\n
Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.\n\n
Метод yield() можно использовать для того чтобы принудить планировщик выполнить другой поток, который ожидает своей очереди.',
        'CORE3_MULTITHREADING', false),
       ('Как работает метод Thread.join()? Для чего он используется?', 'Метод join() приостанавливает выполнение текущего потока до тех пор, пока не завершится другой поток.\n\n
Например, если есть 2 потока, t1 и t2, и написать — t1.join(), то t2 не начнёт работу, пока t1 не завершит свою.\n\n
Метод join() можно использовать, чтобы гарантировать последовательность выполнения потоков.', 'CORE3_MULTITHREADING',
        false),
       ('В чем разница между методами wait() и sleep()?',
        'В отличие от метода wait(), при вызове sleep() текущий поток не освобождает монитор объекта, на котором он был вызван, и поэтому другой поток не может получить доступ к этому объекту, пока поток не вернется из режима сна.\n\n Таким образом,метод wait() используется для синхронизации потоков и координирования их работы, а метод sleep() используется для задержки выполнения потока на определенное время.',
        'CORE3_MULTITHREADING', false),
       ('Можно ли вызвать start() для одного потока дважды?',
        'Нельзя стартовать поток больше, чем единожды. В частности, поток не может быть перезапущен, если он уже завершил выполнение.',
        'CORE3_MULTITHREADING', false),
       ('Как правильно остановить поток? Какие методы .stop(), .interrupt(), .interrupted(), .isInterrupted() используются и для каких целей?', 'Методом stop() пользоваться нельзя, метод помечен как deprecated. Такая жесткая остановка моментально возвращает все захваченные потоком  мониторы, и защищенные ими данные могут оказаться в неконсистентном состоянии.\n\n
Методы interrupt, interrupted, isInterrupted связаны с функцией прерывания потока:\n
- interrupt() — выставляет флаг прерывания на конкретном потоке, указывая, что ему следует остановиться. Ставит значение флага true\n\n.
- bool Thread.interrupted() — возвращает значение флага прерывания для текущего потока. После проверки всегда присваивает значение флага false и запускает поток.\n\n
- bool isInterrupted() — возвращает значение флага прерывания для того объекта, на котором вызван.Не запускает поток.\n\n
Как правильно остановить поток в Java?\n
Вместо принудительной остановки потока необходимо использовать метод оповещения о прекращении работы потока - interrupt(). Данный метод установит флаг прерывания потока (прекращения работы), который можно проверить методом isInterrupted() и указать логику его обработки и завершения работы потока.',
        'CORE3_MULTITHREADING', false),
       ('В чем различия между интерфейсами Runnable и Callable?', 'Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;\n\n
Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run(). Классы, реализующие интерфейс Callable - метод call();\n\n
Метод Runnable.run() не возвращает никакого значения\n
Callable - это параметризованный функциональный интерфейс. Callable.call() возвращает Object, если он не параметризован, иначе указанный тип.\n
Метод run() НЕ может выбрасывать проверяемые исключения, в то время как метод call() может.', 'CORE3_MULTITHREADING',
        false),
       ('Что представляет собой FutureTask?',
        'Интерфейс java.util.concurrent.Future описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.\n\n FutureTask представляет собой отменяемое асинхронное вычисление в параллельном потоке.\n Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления, методами для запроса состояния вычисления и извлечения результатов.\n Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено.\n Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.',
        'CORE3_MULTITHREADING', false),
       ('Что такое deadlock (взаимная блокировка)?', 'Взаимная блокировка (deadlock) - это состояние системы, которое возникает, когда два или более потоков навсегда остаются заблокированными, ожидая ресурсы, занятые друг другом.\n\n

Для возникновения deadlock необходимо выполнение следующих условий:\n

\t1. Эксклюзивное владение ресурсом: Поток будет удерживать ресурс, и только он может использовать этот ресурс.\n
\t2. Удержание и ожидание: Поток, который удерживает ресурс, ожидает другой ресурс, который удерживает другой поток.\n
\t3. Отсутствие принудительного освобождения: Ресурсы не могут быть принудительно изъяты у потоков.\n
\t4. Циклическое ожидание: Существует цикл, в котором каждый поток ждет ресурс, занятый следующим потоком в цепочке.\n\n

Пример deadlock на Java:\n\n

public class DeadlockExample {\n\n

    \tpublic static void main(String[] args) {\n
        \t\tfinal Object resource1 = "resource1";\n
        \t\tfinal Object resource2 = "resource2";\n\n

        \t\tThread thread1 = new Thread(new Runnable() {\n
            \t\t\t@Override\n
            \t\t\tpublic void run() {\n
                \t\t\t\tsynchronized (resource1) {\n
                    \t\t\t\t\tSystem.out.println("Thread 1: locked resource 1");\n\n

                    \t\t\t\t\ttry { Thread.sleep(50); } catch (InterruptedException e) {}\n\n

                    \t\t\t\t\tsynchronized (resource2) {\n
                        \t\t\t\t\t\tSystem.out.println("Thread 1: locked resource 2");\n
                    \t\t\t\t\t}\n
                \t\t\t\t}\n
            \t\t\t}\n
        \t\t});\n\n

        \t\tThread thread2 = new Thread(new Runnable() {\n
            \t\t\t@Override\n
            \t\t\tpublic void run() {\n
                \t\t\t\tsynchronized (resource2) {\n
                    \t\t\t\t\tSystem.out.println("Thread 2: locked resource 2");\n\n

                    \t\t\t\t\ttry { Thread.sleep(50); } catch (InterruptedException e) {}\n\n

                    \t\t\t\t\tsynchronized (resource1) {\n
                        \t\t\t\t\t\tSystem.out.println("Thread 2: locked resource 1");\n
                    \t\t\t\t\t}\n
                \t\t\t\t}\n
            \t\t\t}\n
        \t\t});\n\n

        \t\tthread1.start();\n
        \t\tthread2.start();\n
    \t}\n
}\n\n

В этом примере два потока thread1 и thread2 захватывают ресурсы в разном порядке, что может привести к deadlock.\n\n

Чтобы избежать deadlock, необходимо вводить правильные стратегии управления ресурсами, такие как:\n

\t- Не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.\n
\t- Использование тайм-аутов при попытке захвата ресурсов.\n
\t- Избегать удержания более одного ресурса одновременно, если это возможно.', 'CORE3_MULTITHREADING', true),
       ('Что такое livelock? Как он отличается от deadlock?', 'Livelock (блокировка, приводящая к бездействию) - это состояние, при котором два или более потоков постоянно меняют свое состояние в ответ друг на друга, но никакой из них не делает дальнейшего прогресса. В отличие от deadlock, где потоки полностью заблокированы, в livelock потоки продолжают выполнять действия, но без достижения требуемого результата.\n\n

Основные отличия между deadlock и livelock:\n\n

\t- Deadlock: Потоки полностью заблокированы и ничего не делают.\n
\t- Livelock: Потоки активны, постоянно изменяют свое состояние, но не делают никакого полезного прогресса.',
        'CORE3_MULTITHREADING', true),
       ('Что представляет собой race condition?',
        '\tВ контексте Java race condition возникает, когда два или более потоков одновременно обращаются к общему ресурсу (например, переменной, коллекции, объекту) и пытаются изменить его, что может привести к неожиданным или некорректным результатам.\n \t Методы для предотвращения Race Condition в Java:\n 1. Использование ключевого слова synchronized\n 2. Использование объекта ReentrantLock\n 3. Использование атомарных типов',
        'CORE3_MULTITHREADING', true),
       ('Что такое фреймворк fork/join? Какова его роль и назначение?', 'Фреймворк Fork/Join, представленный в JDK 7, - это набор классов и интерфейсов позволяющих использовать преимущества многопроцессорной архитектуры современных компьютеров.\n Он разработан для выполнения задач, которые можно рекурсивно разбить на маленькие подзадачи, которые можно решать параллельно.\n\n
Этап Fork: большая задача разделяется на несколько меньших подзадач, которые в свою очередь также разбиваются на меньшие. И так до тех пор, пока задача не становится тривиальной и решаемой последовательным способом.\n\n
Этап Join: далее (опционально) идёт процесс «свёртки» - решения подзадач некоторым образом объединяются пока не получится решение всей задачи.\n\n
Решение всех подзадач (в т.ч. и само разбиение на подзадачи) происходит параллельно.\n
Для решения некоторых задач этап Join не требуется. Например, для параллельного QuickSort — массив рекурсивно делится на всё меньшие и меньшие диапазоны, пока не вырождается в тривиальный случай из 1 элемента. Хотя в некотором смысле Join будет необходим и тут, т.к. всё равно остаётся необходимость дождаться пока не закончится выполнение всех подзадач.\n\n
Ещё одно преимущество этого фреймворка заключается в том, что он использует work-stealing алгоритм: потоки, которые завершили выполнение собственных подзадач, могут «украсть» подзадачи у других потоков, которые всё ещё заняты.',
        'CORE3_MULTITHREADING', false),
       ('Что входит в java.util.concurrent?', 'Классы и интерфейсы пакета java.util.concurrent объедининены в несколько групп по функциональному признаку:\n\n  collections - CopyOnWriteArrayList(Set), ConcurrentHashMap. Итераторы классов данного пакета представляют данные на определенный момент времени. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Этим гарантируется, что при проходе итератором по коллекции не будет ConcurrentModificationException.\n\n
synchronizers - Объекты синхронизации, позволяющие разработчику управлять и/или ограничивать работу нескольких потоков. Cодержит пять объектов синхронизации: semaphore, countDownLatch, ciclycBarrier, exchanger, phaser.\n\n
atomic - Набор атомарных классов для выполнения атомарных операций (AtomicInteger, AtomicLong, AtomicBoolean). Операция является атомарной, если её можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.\n\n Locks - Механизмы синхронизации потоков, альтернативы базовым synchronized, wait, notify, notifyAll: Lock, Condition, ReadWriteLock.\n\n
Executors - включает средства, называемые сервисами исполнения, позволяющие управлять потоковыми задачами с возможностью получения результатов через интерфейсы Future и Callable.',
        'CORE3_MULTITHREADING', true),
       ('Что такое Executor в контексте пакета java.util.concurrent?', 'В Java Executor - это интерфейс из пакета java.util.concurrent, который предоставляет абстракцию для выполнения асинхронных задач. Он представляет собой механизм для управления потоками и позволяет разделять задачи на более мелкие, выполняемые параллельно.\n\n
Executor обеспечивает разделение между задачей (что нужно выполнить) и механизмом выполнения (как это будет выполнено). Он определяет всего один метод:\n\n
   void execute(Runnable command);\n\n
Метод execute() принимает объект типа Runnable (или его подклассы) в качестве параметра и назначает его для выполнения. Исполнение самой задачи может происходить в отдельном потоке, пуле потоков или другой среде исполнения, управляемой конкретной реализацией Executor.\n\n
Некоторые распространенные реализации интерфейса Executor включают:\n\n
- ExecutorService: Расширяет интерфейс Executor и добавляет дополнительные возможности, такие как возвратные значения и завершение задач. Предоставляет методы для управления циклами выполнения и получения результатов задач.\n\n
- ThreadPoolExecutor: Реализация ExecutorService, которая создает и управляет пулом потоков для выполнения задач. Позволяет контролировать параметры пула потоков, такие как размер пула, очередь задач и политику отклонения задач.\n\n
- ScheduledExecutorService: Расширение ExecutorService, которое поддерживает планирование выполнения задач в определенное время или с определенной периодичностью. Позволяет создавать периодические задачи и запускать их с заданным интервалом.',
        'CORE3_MULTITHREADING', false),
       ('Как создать и использовать пул потоков с помощью ExecutorService?', 'Для создания и использования пула потоков с помощью ExecutorService можно использовать следующие классы:\n\n
1. ThreadPoolExecutor — реализует интерфейс ExecutorService и обеспечивает поддержку управляемого пула потоков исполнения.\n\n
2. ScheduledThreadPoolExecutor — реализует интерфейс ScheduledExecutorService для поддержки планирования пула потоков исполнения.\n\n
3. ForkJoinPool — реализует интерфейс ExecutorService и применяется в каркасе Fork/Join Framework.\n\n
При запуске задач с помощью Executor пакета java.util.concurrent не требуется прибегать к низкоуровневой поточной функциональности класса Thread, достаточно создать объект типа ExecutorService с нужными свойствами и передать ему на исполнение задачу типа Callable.',
        'CORE3_MULTITHREADING', false),
       ('Как использовать CountDownLatch для ожидания завершения определенного числа задач?',
        'Принцип работы CountDownLatch заключается в том, что вы создаете объект CountDownLatch с определенным счетчиком, который инициализируется при создании. Затем один или несколько потоков могут уменьшать этот счетчик, вызывая метод countDown(). Другие потоки могут ждать, пока счетчик не станет равным нулю, вызывая метод await().',
        'CORE3_MULTITHREADING', false),
       ('Что представляет собой CyclicBarrier и в каких сценариях он может быть полезен?', 'CyclicBarrier реализует шаблон синхронизации [Барьер]. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (`CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)`) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».\n\n
Примеры сценариев, где может быть полезен CyclicBarrier:\n\n
1. Разделение задачи на подзадачи.\n
2. Распределённые вычисления.\n
3. Симуляция многократного выполнения задач.', 'CORE3_MULTITHREADING', false),
       ('Что представляют собой классы ReentrantLock и ReentrantReadWriteLock?', 'ReentrantLock:\n
* Реализует блокировку взаимного исключения (mutex) в Java.\n
* Позволяет потоку приобретать и освобождать один и тот же замок несколько раз.\n
* Обеспечивает исключительную блокировку, то есть только один поток может владеть замком в любой момент времени.\n\n
ReentrantReadWriteLock:\n
* Является более сложной версией ReentrantLock, которая поддерживает как исключительную, так и разделяемую блокировки.\n
* Предоставляет два типа блокировок:\n
    - Блокировка чтения: Позволяет нескольким потокам одновременно считывать данные, защищенные замком.\n
    - Блокировка записи: Предоставляет исключительную блокировку, как и ReentrantLock, позволяя только одному потоку записывать данные, защищенные замком.',
        'CORE3_MULTITHREADING', false),
       ('Как работает Phaser и для чего может быть использован?', 'Phaser определяет объект синхронизации, который ждёт, пока не завершится определённая фаза. Затем Phaser переходит к следующей стадии или фазе и снова ожидает её завершения.\n\n
Основные методы класса Phaser:\n
- int register(): регистрирует участника, который выполняет фазы, и возвращает номер текущей фазы;\n
- int arrive(): сообщает, что участник завершил фазу, и возвращает номер текущей фазы;\n
- int arriveAndAwaitAdvance(): аналогичен методу arrive, только при этом заставляет Phaser ожидать завершения фазы всеми остальными участниками;\n
- int arriveAndDeregister(): сообщает о завершении всех фаз участником и снимает его с регистрации.',
        'CORE3_MULTITHREADING', false),
       ('Что представляет собой ConcurrentHashMap и где используется?', '* Является реализацией Map в Java, которая обеспечивает безопасную для потоков одновременную модификацию.\n\n
* Использует сегментированную архитектуру для повышения параллелизма и масштабируемости.\n
* Подходит для приложений с высокой конкурентностью, где несколько потоков одновременно обращаются к данным Map.\n\n
    Где используется:\n
* Кэширование данных\n
* Общие структуры данных между потоками\n
* Многопоточные приложения с высокими требованиями к производительности\n
* Системы с большим количеством одновременных запросов\n\n
    Преимущества:n
* Безопасность для потоков\n
* Высокая производительность\n
* Масштабируемость\n
* Поддержка одновременных операций чтения и записи', 'CORE3_MULTITHREADING', false),
       ('Что представляет собой ThreadLocal и где используется?',
        'ThreadLocal - это класс в Java, который предоставляет способ создания переменных, которые могут быть доступны только в контексте одного потока. Эти переменные хранятся внутри объекта ThreadLocal и не видны другим потокам.\n\n ThreadLocal может быть полезен, когда необходимо создать переменную, которая должна быть локальной для каждого потока, например, когда нужно сохранять состояние при обработке запросов от разных клиентов в многопоточном сервере.',
        'CORE3_MULTITHREADING', false),
       ('Как связаны Stream API и ForkJoinPool? Что представляют из себя?', 'В Stream API есть простой способ распараллеливания потока метедом parallel() или parallelStream(), чтобы получить выигрыш в производительности на многоядерных машинах.\n\n
По-умолчанию parallel stream используют ForkJoinPool.commonPool. Этот пул создается статически и живет пока не будет вызван System::exit. Если задачам не указывать конкретный пул, то они будут исполняться в рамках commonPool.\n\n
По-умолчанию, размер пула равен на 1 меньше, чем количество доступных ядер.\n\n
Когда некий тред отправляет задачу в common pool, то пул может использовать вызывающий тред (caller-thread) в качестве воркера. ForkJoinPool пытается загрузить своими задачами и вызывающий тред.',
        'CORE3_MULTITHREADING', false),
       ('Что такое Java Memory Model?', 'Java Memory Model (JMM) — это спецификация, определяющая правила взаимодействия потоков с памятью в языке программирования Java. JMM описывает, как изменения в памяти, сделанные одним потоком, становятся видимыми для других потоков и как должны упорядочиваться операции чтения и записи.\n\n Основные понятия включают:\n

\t1. Видимость: JMM определяет, какие переменные в памяти видимы каждому потоку и как изменения, внесенные одним потоком, становятся видимыми другим потокам. Например, без специальной синхронизации, один поток может не увидеть изменения, сделанные другим потоком.\n\n
\t2. Атомарность: Неделимые операции (например, чтение/запись переменных типа int).\n\n
\t3. Перестановка инструкций: JMM определяет правила упорядочивания операций. Это важно, поскольку компилятор и процессор могут изменять порядок выполнения инструкций ради оптимизации JMM задает границы, за которые перестановка инструкций не может выйти, чтобы не нарушить корректность программы.\n\n
\t4. Синхронизация: Использование synchronized, volatile и других механизмов для обеспечения корректного взаимодействия между потоками.\n\n

JMM помогает предотвратить проблемы многопоточности, такие как гонки данных (race conditions) и ошибки синхронизации, обеспечивая предсказуемость и корректную работу многопоточных программ.',
        'CORE3_MULTITHREADING', true),
       ('Что такое reordering, happens-before и область видимости?', 'Reordering (переупорядочивание):\n\n
* В многопоточных программах компилятор и процессор могут переупорядочивать инструкции для повышения производительности.\n
* Переупорядочивание может привести к тому, что порядок выполнения инструкций в исходном коде не будет совпадать с порядком их фактического выполнения.\n\n
Happens-before (происходит до):\n\n
* Отношение, которое определяет порядок выполнения инструкций в многопоточной программе.\n
* Если инструкция A происходит до инструкции B, то изменения, внесенные инструкцией A, будут видны инструкции B, даже если они выполняются в разных потоках.\n\n
Область видимости:\n\n
* Определяет, какой поток может видеть изменения, внесенные в переменную.\n
* В Java есть два типа областей видимости:\n
    \t- Локальная область видимости потока: Переменные, объявленные внутри метода, видны только в этом методе.\n
    \t- Область видимости потокобезопасности: Переменные, объявленные как volatile или защищенные синхронизацией, видны всем потокам.',
        'CORE3_MULTITHREADING', true),
       ('Что такое ORM? Что такое JPA? Что такое Hibernate?', 'ORM(Object Relational Mapping) - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования.\n\n JPA(Java Persistence API) - это стандартная для Java спецификация, описывающая принципы ORM. JPA не умеет работать с объектами, а только определяет правила как должен действовать каждый провайдер (Hibernate, EclipseLink), реализующий стандарт JPA\n\n (Plain Old Java Object - POJO)\n  Hibernate - библиотека, являющаяся реализацией этой спецификации, в которой можно использовать стандартные API-интерфейсы JPA.\n\n
Важные интерфейсы Hibernate:\n * Session - обеспечивает физическое соединение между приложением и БД. Основная функция - предлагать DML-операции для экземпляров сущностей.\n * SessionFactory - это фабрика для объектов Session. Обычно создается во время запуска приложения и сохраняется для последующего использования. Является потокобезопасным объектом и используется всеми потоками приложения.\n * Transaction - однопоточный короткоживущий объект, используемый для атомарных операций. Это абстракция приложения от основных JDBC транзакций. Session может занимать несколько Transaction в определенных случаях, является необязательным API./n * Query - интерфейс позволяет выполнять запросы к БД. Запросы написаны на HQL или на SQL.',
        'HIBERNATE_JDBC', false),
       ('Что такое EntityManager?', 'EntityManager это интерфейс, который описывает API для всех основных операций над Enitity, получение данных и других сущностей JPA. По сути главный API для работы с JPA.\n\n Основные операции:\n
1) Для операций над Entity: persist (добавление Entity под управление JPA), merge (обновление), remove (удаления), refresh (обновление данных), detach (удаление из управление JPA), lock (блокирование Enity от изменений в других thread)\n\n
2) Получение данных: find (поиск и получение Entity), createQuery, createNamedQuery, createNativeQuery, contains, createNamedStoredProcedureQuery, createStoredProcedureQuery\n\n
3) Получение других сущностей JPA: getTransaction, getEntityManagerFactory, getCriteriaBuilder, getMetamodel, getDelegate\n\n
4) Работа с EntityGraph: createEntityGraph, getEntityGraph\n\n
5) Общие операции над EntityManager или всеми Entities: close, isOpen, getProperties, setProperty, clear',
        'HIBERNATE_JDBC', false),
       ('Каким условиям должен удовлетворять класс чтобы являться Entity?', 'Entity это легковесный хранимый объект бизнес логики. Основная программная сущность это entity-класс, который так же может использовать дополнительные классы, которые могут использоваться как вспомогательные классы или для сохранения состояния еntity.\n\n
1) Entity класс должен быть помечен аннотацией Entity или описан в XML файле\n 2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами) - при получении данных из БД и формировании из них объекта сущности, Hibernate должен создать этот самый объект сущности\n 3) Entity класс должен быть классом верхнего уровня (top-level class)\n 4) Entity класс не может быть enum или интерфейсом\n 5) Entity класс не может быть финальным классом (final class)\n 6) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables)\n 7) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс\n 8) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе)\n 9) Entity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Entity класса в базе данных
', 'HIBERNATE_JDBC', false),
       ('Может ли абстрактный класс быть Entity?', 'Может, при этом он сохраняет все свойства Entity, отличается от обычных Entity классов только тем, что нельзя создать объект этого
класса. Абстрактные Entity классы используются в наследовании, когда их потомки
наследуют поля абстрактного класса', 'HIBERNATE_JDBC', false),
       ('Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?', 'Может', 'HIBERNATE_JDBC',
        false),
       ('Может ли Entity класс наследоваться от других Entity классов?', 'Может', 'HIBERNATE_JDBC', false),
       ('Может ли не Entity класс наследоваться от Entity класса?', 'Может', 'HIBERNATE_JDBC', false),
       ('Что такое встраиваемый (Embeddable) класс? Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?', 'Embeddable класс - это класс, который не используется сам по себе, а является частью одного или нескольких Entity-классов. Entity-класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map. Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity-класса и не может быть использован для передачи данных между объектами Entity-классов (то есть такой класс не является общей структурой данных для разных объектов). В целом, такой класс служит для того чтобы выносить определение общих атрибутов для нескольких Entity.\n\n
1. Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity\n\n 2. Embeddable класс должен быть помечен аннотацией @Embeddable или описан в XML файле конфигурации JPA. А поле этого класса в Entity аннотацией @Embedded. От Embeddable класса нельзя наследоваться - конечный класс Стоит использовать если класс конечный\n\n
Embeddable-класс может содержать другой встраиваемый класс. Embeddable Person может имент поле класса Adress - тогда в Student пишем adress.имяполя.\n\n
Встраиваемый класс может содержать связи с другими Entity или коллекциями Entity, если такой класс не используется как первичный ключ или ключ map''ы. Так как мы можем встраивать классы в неограниченное количество других классов, то у каждого класса, содержащего встраиваемый класс, мы можем изменить названия полей из встраиваемого класса. Например, у класса Driver поля из встраиваемого класса Person будут изменены с name на driver_name и с age на driver_age. Делаем с помощью аннотации AttributeOverride - также класс Embeddable "Person" может быть встроет в Studen и с помощью AttributeOverride можно задать для 2 персон "муж и жен пол" 2 разделения. @AssociationOverride - в Embeddable Person есть объект Embeddable Adress а в нем связть MonyToOne с другой таблицой Street для этого в Studen ставим аннотацию @AssociationOverride над Person и подключаем @AssociationOverride(name = adress.street joinColumns = @JoinColumn(name))',
        'HIBERNATE_JDBC', false),
       ('Что такое Mapped Superclass?', 'Mapped Superclass - (позволяет обойти блокировку наследования Embeddable-классов, то есть от такого класса мы можем наследоваться, также в классе Entity если мы используем класс MappedSuperclass то над ним нужно ставить аннтотацию @Embedded)  это класс, от которого наследуются Entity , он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или описан в xml файле.\n
Создание такого класса-предка оправдано тем, что мы заранее определяем ряд свойств и методов, которые должны быть определены в сущностях. Использование такого подхода позволило сократить количество кода.',
        'HIBERNATE_JDBC', false),
       ('Какие три типа стратегий наследования мапинга (Inheritance Mapping Strategies) описаны в JPA?', 'Inheritance Mapping Strategies Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) как ему отображать в БД сущности-наследники: 1) Одна таблица на всю иерархию классов (SINGLE_TABLE) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”. Например, если есть entity Animals c классами-потомками Cats и Dogs, при такой стратегии все entity записываются в таблицу Animals, но при это имеют дополнительную колонку animalType в которую соответственно пишется значение «cat» или «dog». Минусом является то что в общей таблице, будут созданы все поля уникальные для каждого из классов-потомков, которые будет пусты для всех других классов-потомков. Например, в таблице animals окажется и скорость лазанья по дереву от cats и может ли пес приносить тапки от dogs, которые будут всегда иметь null для dog и cat соотвественно. Минусом стратегии является невозможность применения ограничения NOT NULL для тех колонок таблицы, которые характерны только для классов-наследников., но можно использовать тригеры. Является стратегией по умолчанию. @DiscriminatorColumn(name = "EMP_TYPE") - имя общей колонки указывающий на принодлежность к классу @DiscriminatorValue("P") - указывает какое имя будет отображенно в @DiscriminatorColumn\n\n
2) Стратегия «соединения» (JOINED) — В данной стратегии корневой класс иерархии представлен отдельной таблицей, а каждый класс-наследник имеет свою таблицу, в которой отображены только поля этого класса-наследника., дополнительно устанавливается связь (relationships) между этими таблицами, например в случае классов Animals (см.выше), будут три таблицы animals, cats, dogs, причем в cats будет записана только ключ и скорость лазанья, в dogs — ключ и умеет ли пес приносить палку, а в animals все остальные данные cats и dogs c ссылкой на соответствующие таблицы. Минусом тут являются потери производительности от объединения таблиц (join) для любых операций. @Id, который должен быть определен только в родительской таблице.\n\n
3) Таблица для каждого класса (TABLE_PER_CLASS) — каждый отдельный класс-наследник имеет свою таблицу,Во всех таблицах подклассов хранятся все поля этого класса плюс те, которые унаследованы от суперкласса. т.е. для cats и dogs (см.выше) все данные будут записываться просто в таблицы cats и dogs как если бы они вообще не имели общего суперкласса. Минусом является плохая поддержка полиморфизма (polymorphic relationships) и то что для выборки всех классов иерархии потребуются большое количество отдельных sql запросов или использование UNION запроса.  Для задания стратегии наследования используется аннотация Inheritance (или соответствующие блоки)',
        'HIBERNATE_JDBC', false),
       ('Как мапятся Enum`ы?', 'В JPA (Java Persistence API) перечисления (Enum) могут быть отображены на базу данных различными способами:\n\n
1. **Ординальный маппинг (Ordinal Mapping)**. Значения Enum сохраняются в базе данных в виде числового индекса (порядкового номера).\n\n
2. **Строковый маппинг (String Mapping)**. Значения Enum сохраняются в базе данных в виде соответствующих строковых значений.\n\n
3. **Собственный маппинг (Custom Mapping)**. Можно создать класс-конвертер, реализующий интерфейс AttributeConverter, и затем аннотировать поле Enum аннотацией @Convert, указав созданный конвертер.',
        'HIBERNATE_JDBC', false),
       ('Как мапятся даты (до java 8 и после)?', 'Аннотация @Temporal до Java 8, в которой надо было указать какой тип даты мы хотим использовать.\n
В Java 8 и далее аннотацию ставить не нужно. java.time Все классы в новом API неизменяемые (immutable) и, как следствие,
потоко-безопасные. Точность представления времени составляет одну наносекунду,
что в миллион раз точнее чем в пакете java.util.', 'HIBERNATE_JDBC', false),
       ('Как “смапить” коллекцию примитивов?', ' @ElementCollection\n
 @OrderBy\n
Если у нашей сущности есть поле с коллекцией, то мы привыкли ставить над ним аннотации @OneToMany либо @ManyToMany. Но данные аннотации применяются в случае, когда это коллекция других сущностей (entities). Если у нашей сущности коллекция не других сущностей, а базовых или встраиваемых (embeddable) типов для этих случаев в JPA имеется специальная аннотация @ElementCollection, которая указывается в классе сущности над полем коллекции. Все записи коллекции хранятся в отдельной таблице, то есть в итоге получаем две таблицы: одну для сущности, вторую для коллекции элементов.\n\n
При добавлении новой строки в коллекцию, она полностью очищается и заполняется заново, так как у элементов нет id. Можно решить с помощью @OrderColumn\n
 @CollectionTable - позволяет редактировать таблицу с коллекцией, прочитать', 'HIBERNATE_JDBC', false),
       ('Какие есть виды связей?', 'Существуют 4 типа связей:\n 1. OneToOne - когда один экземпляр Entity может быть связан не больше чем с одним экземпляром другого Entity.\n 2. OneToMany - когда один экземпляр Entity может быть связан с несколькими экземплярами других Entity.\n 3. ManyToOne - обратная связь для OneToMany. Несколько экземпляров Entity могут быть связаны с одним экземпляром другого Entity.\n 4. ManyToMany - экземпляры Entity могут быть связаны с несколькими экземплярами друг друга.\n\n
Каждую из которых можно разделить ещё на два вида:\n 1. Bidirectional Владеемая сторона в двунаправленных отношениях должна ссылаться на владеющую сторону используя элемент mappedBy аннотаций @OneToOne, @OneToMany, или @ManyToMany. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.\n 2. Undirectional В однонаправленных отношениях только одна сущность имеет поле, которое ссылается на вторую сущность. Вторая сущность (сторона) не имеет поля первой сущности и не знает об отношениях. Элемент mappedBy определяет поле в объекте, который является владельцем отношения.\n\n
                                   * Bidirectional (Двунаправленные отношения) — ссылка на связь устанавливается у всех Entity, то есть в случае OneToOne A-B в Entity A есть ссылка на Entity B, в Entity B есть ссылка на Entity A. Entity A считается владельцем этой связи (это важно для случаев каскадного удаления данных, тогда при удалении A также будет удалено B, но не наоборот).\n
* Undirectional- ссылка на связь устанавливается только с одной стороны, то есть в случае OneToOne A-B только у Entity A будет ссылка на Entity B, у Entity B ссылки на A не будет.',
        'HIBERNATE_JDBC', false),
       ('Что такое владелец связи?', 'В отношениях между двумя сущностями всегда есть одна владеющая сторона, а владеемой может и не быть, если это однонаправленные отношения.\n\n
По сути, у кого есть внешний ключ на другую сущность - тот и владелец связи. То есть, если в таблице одной сущности есть колонка, содержащая внешние ключи от другой сущности, то первая сущность признаётся владельцем связи, вторая сущность - владеемой.\n\n
В однонаправленных отношениях сторона, которая имеет поле с типом другой сущности, является владельцем этой связи по умолчанию.',
        'HIBERNATE_JDBC', false),
       ('Что такое каскады?', 'Когда выполняется какое-либо действие над целевым объектом, то же самое действие будет применено к связанному объекту.\n
Каскадирования  можно  добиться,  указав  у  любой  из  аннотаций  @OneToOne, @ManyToOne, @OneToMany, @ManyToMany элемент cascade и присвоив ему одно или несколько значений из перечисления CascadeType\n\n
* ALL - все персистные события будут переданы дочернему объекту\n
* DETACH - отключает все связанные сущности при ручном отключении\n
* MERGE - возвращает все связанные сущности в persistant context\n
* PERSIST - операции save() или pesist() какскадно передаются связанным объектам\n
* REFRESH - посторон считывают значение связаннх сущностей при вызове refresh()\n
* REMOVE - удаляет все связанные сущности\n
Как  правило  каскадные  операции  применяются  от  родительской  сущности  к дочерним, но они могут распространяться и в обратном направлении - от дочерней к родительской.',
        'HIBERNATE_JDBC', false),
       ('Что такое orphanRemoval?', 'Два состояния: true и false\n
**True** - при удалении объекта этот объект удаляется из БД\n
**False -** при удалении объекта этот объект НЕ удаляется из БД. Просто его внешний ключ обнуляется и объект больше ни на что не ссылаетсяДва состояния: true и false',
        'HIBERNATE_JDBC', false),
       ('Разница между PERSIST и MERGE?', 'persist(entity) следует использовать с совершенно новыми объектами, чтобы добавить их в БД (если объект уже существует в БД, будет выброшено исключение EntityExistsException).\n\n
Но в случае merge(entity) сущность, которая уже управляется в контексте персистентности, будет заменена новой сущностью (обновленной), и копия этой обновленной сущности вернется обратно. Но рекомендуется использовать для уже сохраненных сущностей.',
        'HIBERNATE_JDBC', false),
       ('Какие два типа fetch стратегии в JPA вы знаете?', '1) LAZY — Hibernate может загружать данные не сразу, а при первом обращении к ним, но так как это необязательное требование, то Hibernate имеет право изменить это поведение и загружать их сразу. Это поведение по умолчанию для полей, аннотированных @OneToMany, @ManyToMany и @ElementCollection. В объект загружается прокси lazy-поля.\n\n
2) EAGER — данные поля будут загруженны немедленно. Это поведение по умолчанию для полей, аннотированных @Basic, @ManyToOne и @OneToOne.',
        'HIBERNATE_JDBC', true),
       ('Какие четыре статуса жизненного цикла Entity объекта (Entity Instance’s Life Cycle) вы можете перечислить?', '1. Transient (New) — свежесозданная оператором new() сущность не имеет связи с базой данных, не имеет данных в базе данных и не имеет сгенерированных первичных ключей.\n
2. managed - объект создан, сохранён в бд, имеет primary key, управляется JPA\n
3. detached -объект создан, имеет primary key, не является (или больше не является) частью контекста персистентности (не управляется JPA);\n
4. removed - объект создан, управляется JPA, будет удален при commit-е и статус станет опять detached',
        'HIBERNATE_JDBC', true),
       ('Как влияет операция persist на Entity объекты каждого из четырех статусов?', 'new → managed, и объект будет сохранен в базу при commit-е транзакции или в результате flush операций\n\n
managed → операция игнорируется, однако зависимые Entity могут поменять статус на managed, если у них есть аннотации каскадных изменений\n\n
detached → exception сразу или на этапе commit-а транзакции\n\n
removed → managed, но только в рамках одной транзакции. ', 'HIBERNATE_JDBC', false),
       ('Как влияет операция remove на Entity объекты каждого из четырех статусов?', 'new → операция игнорируется, однако зависимые Entity могут поменять статус на removed, если у них есть аннотации каскадных изменений и они имели статус managed\n\n
managed → removed и запись объект в базе данных будет удалена при commit-е транзакции (также произойдут операции remove для всех каскадно зависимых объектов)\n\n
detached → exception сразу или на этапе commit-а транзакции\n\n
removed → операция игнорируется', 'HIBERNATE_JDBC', false),
       ('Как влияет операция merge на Entity объекты каждого из четырех статусов?', 'new → будет создана новая managed entity, в которую будут скопированы данные объекта.\n\n
managed → операция игнорируется, однако операция merge сработает на каскадно зависимых entity, если их статус не managed.\n\n
removed → exception сразу или на этапе commit-а транзакции.\n\n
detached → либо данные будут скопированы в существующую БД managed entity с тем же пер', 'HIBERNATE_JDBC', false),
       ('Как влияет операция refresh на Entity объекты каждого из четырех статусов?', 'managed → будут восстановлены все изменения из базы данных данного Entity, также произойдет refresh всех каскадно зависимых объектов\n\n
new, removed, detached → exception
', 'HIBERNATE_JDBC', false),
       ('Как влияет операция detach на Entity объекты каждого из четырех статусов?', 'managed, removed → detached.\n\n
new, detached → операция игнорируется
', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Basic?', ' @Basic - указывает на простейший тип маппинга данных на колонку таблицы базы данных. Также в параметрах аннотации можно указать fetch стратегию доступа к полю и является ли это поле обязательным или нет. Может быть применена к полю любого из следующих типов:\n\n
1. Примитивы и их обертки.\n
2. java.lang.String\n
3. java.math.BigInteger\n
4. java.math.BigDecimal\n
5. java.util.Date\n
6. java.util.Calendar\n
7. java.sql.Date\n
8. java.sql.Time\n
9. java.sql.Timestamp\n
10. byte[] or Byte[]\n
11. char[] or Character[]\n
12. enums\n
13. любые другие типы, которые реализуют Serializable.\n
Вообще, аннотацию @Basic можно не ставить, как это и происходит по умолчанию.\n\n
        Аннотация @Basic определяет 2 атрибута:\n
1. optional - boolean (по умолчанию true) - определяет, может ли значение поля или свойства быть null. Игнорируется для примитивных типов. Но если тип поля не примитивного типа, то при попытке сохранения сущности будет выброшено исключение.\n
2. fetch - FetchType (по умолчанию EAGER) - определяет, должен ли этот атрибут извлекаться незамедлительно (EAGER) или лениво (LAZY). Однако, это необязательное требование JPA, и провайдерам разрешено незамедлительно загружать данные, даже для которых установлена ленивая загрузка.\n\n
Без аннотации @Basic при получении сущности из БД по умолчанию её поля базового типа загружаются принудительно (EAGER) и значения этих полей могут быть null',
        'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Column?', 'Через аннотацию @Column можно явно указать поведение столбца. Если откроете ее реализацию, то увидите, что столбцу можно задавать такие свойства, как уникальность, обновляемость и т.д.\n\n
@Basic vs @Column:\n 1. Атрибуты @Basic применяются к сущностям JPA, тогда как атрибуты @Column применяются к столбцам базы данных.\n 2. @Basic имеет атрибут optional, который говорит о том, может ли поле объекта быть null или нет; с другой стороны атрибут nullable аннотации @Column указывает, может ли соответствующий столбец в таблице быть null.\n 3. Мы можем использовать @Basic, чтобы указать, что поле должно быть загружено лениво.\n 4. Аннотация @Column позволяет нам указать имя столбца в таблице и ряд других свойств:\n a. insertable/updatable - можно ли добавлять/изменять данные в колонке, по умолчанию true;\n  b. length - длина, для строковых типов данных, по умолчанию 255.\n Коротко, в Column (колум) мы задаем constraints (констрейнтс), а в Basic (бейсик) - ФЕТЧ ТАЙП
', 'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Access?', 'Она определяет тип доступа (access type) для класса entity, Mapped Superclass, embeddable или отдельных атрибутов, то есть как JPA будет обращаться к атрибутам entity, как к полям класса (FIELD) или как к свойствам класса (PROPERTY), имеющие гетеры (getter) и сетеры (setter).\n\n  Определяет тип доступа к полям сущности. Для чтения и записи этих полей есть два подхода:\n 1. Field access (доступ по полям). При таком способе аннотации маппинга (Id, Column,...) размещаются над полями, и Hibernate напрямую работает с полями сущности, читая и записывая их.\n 2. Property access (доступ по свойствам). При таком способе аннотации размещаются над методами-геттерами, но никак не над сеттерами. Hibernate использует их и сеттеры для чтения и записи полей сущности.\n\n
По умолчанию тип доступа определяется местом, в котором находится аннотация @Id. Если она будет над полем - это будет AccessType.FIELD, если над геттером - это AccessType.PROPERTY.\n Чтобы явно определить тип доступа у сущности, нужно использовать аннотацию @Access, которая может быть указана у сущности, Mapped Superclass и Embeddable class, а также над полями или методами.\n Поля, унаследованные от суперкласса, имеют тип доступа этого суперкласса.\n Когда у одной сущности определены разные типы доступа, то нужно использовать аннотацию @Transient для избежания дублирования маппинга.',
        'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация @Cacheable?', ' @Cacheable - необязательная аннотация JPA, используется для указания того, должна ли сущность храниться в кэше второго уровня. JPA говорит о пяти значениях shared-cache-mode из persistence.xml, который определяет как будет использоваться second-level cache:\n\n
❖ ENABLE_SELECTIVE: (дефолтное и рекомендуемое значение):только сущности с аннотацией @Cacheable (равносильно значению по умолчанию @Cacheable(value=true)) будут сохраняться в кэше второго уровня.\n\n
❖ DISABLE_SELECTIVE: все сущности будут сохраняться в кэше второго уровня, за исключением сущностей, помеченных @Cacheable(value=false) как некэшируемые.\n\n
❖ ALL: сущности всегда кэшируются, даже если они помечены как некэшируемые.\n\n
❖ NONE: ни одна сущность не кэшируется, даже если помечена как кэшируемая. При данной опции имеет смысл вообще отключить кэш второго уровня.\n\n
❖ UNSPECIFIED: применяются значения по умолчанию для кэша второго уровня, определенные Hibernate. Это эквивалентно тому, что вообще не используется shared-cache-mode, так как Hibernate не включает кэш второго уровня, если используется режим UNSPECIFIED.\n\n
Аннотация @Cacheable размещается над классом сущности. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.',
        'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация @Cache?', 'Это аннотация Hibernate, настраивающая тонкости кэширования объекта в кэше второго уровня Hibernate. @Cache принимает три параметра:\n\n
❖ include - имеет по умолчанию значение all и означающий кэширование всего объекта. Второе возможное значение - non-lazy, запрещает кэширование лениво загружаемых объектов. Кэш первого уровня не обращает внимания на эту директиву и всегда кэширует лениво загружаемые объекты.\n\n
❖ region - позволяет задать имя региона кэша для хранения сущности. Регион можно представить как разные области кэша, имеющие разные настройки на уровне реализации кэша. Например, можно было бы создать в конфигурации ehcache два региона, один с краткосрочным хранением объектов, другой с долгосрочным и отправлять часто изменяющиеся объекты в первый регион, а все остальные - во второй. Ehcache по умолчанию создает регион для каждой сущности с именем класса этой сущности, соответственно в этом регионе хранятся только эти сущности. К примеру, экземпляры Foo хранятся в Ehcache в кэше с именем “com.baeldung.hibernate.cache.model.Foo”.\n\n
❖ usage - задаёт стратегию одновременного доступа к объектам.\n
transactional\n
read-write\n
nonstrict-read-write\n
read-only', 'HIBERNATE_JDBC', false),
       ('Для чего нужны аннотации @Embedded и @Embeddable?', '@Embeddable - аннотация JPA, размещается над классом для указания того, что класс является встраиваемым в другие классы.\n\n
@Embedded - аннотация JPA, используется для размещения над полем в классе-сущности для указания того, что мы внедряем встраиваемый класс.',
        'HIBERNATE_JDBC', false),
       ('Как смапить составной ключ?', 'Для маппинга составного ключа (composite key) в JPA (Java Persistence API) можно использовать несколько подходов, в зависимости от требований и структуры данных:\n\n
1. Аннотация @EmbeddedId. Создайте класс, который представляет составной ключ, и пометьте его аннотацией @Embeddable. Затем в основной сущности используйте аннотацию @EmbeddedId для указания поля, которое будет содержать составной ключ.\n\n
2. Аннотация @IdClass**. Создайте класс, который представляет составной ключ, и пометьте его аннотацией @IdClass. Затем в основной сущности используйте аннотацию @IdClass для указания класса составного ключа.\n\n
В обоих случаях важно, чтобы класс составного ключа реализовывал методы equals() и hashCode(), чтобы обеспечить правильное сравнение и идентификацию составного ключа.',
        'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация ID? Какие @GeneratedValue вы знаете?', 'Аннотация @Id определяет простой (не составной) первичный ключ, состоящий из одного поля. В соответствии с JPA, допустимые типы атрибутов для первичного ключа:\n 1. примитивные типы и их обертки;\n 2. строки;\n 3. BigDecimal и BigInteger;\n 4. java.util.Date и java.sql.Date.\n\n
Если мы хотим, чтобы значение первичного ключа генерировалось для нас автоматически, мы можем добавить первичному ключу, отмеченному аннотацией @Id, аннотацию @GeneratedValue. Аннотация @GeneratedValue предназначена для настройки способа приращения указанного столбца(поля).\n Возможно 4 варианта:\n  AUTO(default) - Указывает, что Hibernate должен выбрать подходящую стратегию для конкретной базы данных, учитывая её диалект, так как у разных БД разные способы по умолчанию. Поведение по умолчанию - исходить из типа поля идентификатора.\n  IDENTITY - для генерации значения первичного ключа будет использоваться столбец IDENTITY, имеющийся в базе данных. Значения в столбце автоматически увеличиваются вне текущей выполняемой транзакции(на стороне базы, так что этого столбца мы не увидим), что позволяет базе данных генерировать новое значение при каждой операции вставки. В промежутках транзакций сущность будет сохранена.\n\n
SEQUENCE - тип генерации, рекомендуемый документацией Hibernate. Для получения значений первичного ключа Hibernate должен использовать имеющиеся в базе данных механизмы генерации последовательных значений (Sequence). В бд можно будет увидеть дополнительную таблицу. Но если наша БД не поддерживает тип SEQUENCE, то Hibernate автоматически переключится на тип TABLE. В промежутках транзакций сущность не будет сохранена, так как хибер возьмет из таблицы id hibernate-sequence и вернётся обратно в приложение.\n SEQUENCE - это объект базы данных, который генерирует инкрементные целые числа при каждом последующем запросе.\n TABLE - Hibernate должен получать первичные ключи для сущностей из создаваемой для этих целей таблицы, способной содержать именованные сегменты значений для любого количества сущностей. Требует использования пессимистических блокировок, которые помещают все транзакции в последовательный порядок и замедляет работу приложения.
', 'HIBERNATE_JDBC', false),
       ('Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?', ' @JoinColumn используется для указания столбца FOREIGN KEY, используемого при установлении связей между сущностями или коллекциями. Мы помним, что только сущность-владелец связи может иметь внешние ключи от другой сущности (владеемой). Однако, мы можем указать @JoinColumn как во владеющей таблице, так и во владеемой, но столбец с внешними ключами всё равно появится во владеющей таблице.\n  Особенности использования:\n
❖ @OneToOne: означает, что появится столбец в таблице сущности-владельца связи, который будет содержать внешний ключ, ссылающийся на первичный ключ владеемой сущности.\n
❖ @OneToMany/@ManyToOne: если не указать на владеемой стороне связи атрибут mappedBy, создается joinTable с ключами обеих таблиц. Но при этом же у владельца создается столбец с внешними ключами.\n\n
 @JoinColumns используется для группировки нескольких аннотаций @JoinColumn, которые используются при установлении связей между сущностями или коллекциями, у которых составной первичный ключ и требуется несколько колонок для указания внешнего ключа.\n В каждой аннотации @JoinColumn должны быть указаны элементы name и referencedColumnName.\n\n
 @JoinTable используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.\n - @JoinTable(name = "CATALOG", joinColumns = @JoinColumn(name = "ID_BOOK"), inverseJoinColumns = @JoinColumn(name = "ID_STUDENT"))\n  private Student student;',
        'HIBERNATE_JDBC', false),
       ('Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?', ' @OrderBy указывает порядок, в соответствии с которым должны располагаться элементы коллекций сущностей, базовых или встраиваемых типов при их извлечении из БД. Если в кэше есть нужные данные, то сортировки не будет.\n Так как @OrderBy просто добавляет к sql-запросу Order By, а при получении данных из кэша, обращения к бд нет. Эта аннотация может использоваться с аннотациями @ElementCollection, @OneToMany, @ManyToMany. При использовании с коллекциями базовых типов, которые имеют аннотацию @ElementCollection, элементы этой коллекции будут отсортированы в натуральном порядке, по значению базовых типов.\n\n
Если это коллекция встраиваемых типов (@Embeddable), то используя точку (".") мы можем сослаться на атрибут внутри встроенного атрибута.\n  Если это коллекция сущностей, то у аннотации @OrderBy можно указать имя поля сущности, по которому сортировать эти самые сущности\n Если мы не укажем у @OrderBy параметр, то сущности будут упорядочены по первичному ключу. \nВ случае с сущностями доступ к полю по точке не работает. Попытка использовать вложенное свойство, например @OrderBy ("supervisor.name") повлечет Runtime Exceprtion.\n\n
 @OrderColumn создает в таблице столбец с индексами порядка элементов, который используется для поддержания постоянного порядка в списке, но этот столбец не считается частью состояния сущности или встраиваемого класса. Hibernate отвечает за поддержание порядка как в базе данных при помощи столбца, так и при получении сущностей и элементов из БД. Hibernate отвечает за обновление порядка при записи в базу данных, чтобы отразить любое добавление, удаление или иное изменение порядка, влияющее на список в таблице.\n\n
 @OrderBy vs @OrderColumn Порядок, указанный в @OrderBy, применяется только в рантайме при выполнении запроса к БД, То есть в контексте персистентности, в то время как при использовании @OrderColumn, порядок сохраняется в отдельном столбце таблицы и поддерживается при каждой вставке/обновлении/удалении элементов.',
        'HIBERNATE_JDBC', false),
       ('Для чего нужна аннотация Transient?', ' @Transient используется для объявления того, какие поля у сущности, встраиваемого класса или Mapped SuperClass не будут сохранены в базе данных.\n
Persistent fields (постоянные поля) - это поля, значения которых будут по умолчанию сохранены в БД. Ими являются любые не static и не final поля.\n
Transient fields (временные поля):\n
❖ static и final поля сущностей;\n
❖ иные поля, объявленные явно с использованием Java-модификатора transient, либо JPA-аннотации @Transient.',
        'HIBERNATE_JDBC', false),
       ('Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?', 'В порядке от самого ненадежного и быстрого, до самого надежного и медленного:\n 1. NONE — без блокировки.\n 2. OPTIMISTIC (синоним READ в JPA 1) — оптимистическая  блокировка, которая работает, как описано ниже: если при завершении транзакции кто-то извне изменит поле @Version, то будет сделан RollBack транзакции и будет выброшено OptimisticLockException.\n 3. OPTIMISTIC_FORCE_INCREMENT (синоним WRITE в JPA 1) — работает по тому же алгоритму, что и LockModeType.OPTIMISTIC за тем исключением, что после commit значение поле Version принудительно увеличивается на 1. В итоге окончательно после каждого коммита поле увеличится на 2(увеличение, которое можно увидеть в Post-Update + принудительное увеличение).\n 4. PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. Использование этой блокировки может вызывать долгое ожидание блокировки или даже выкидывание PessimisticLockException.\n 5. PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать и не может их читать до окончания транзакции, владеющей блокировкой. Использование этой блокировки может вызывать долгое ожидание блокировки.\n 6. PESSIMISTIC_FORCE_INCREMENT — ведёт себя как PESSIMISTIC_WRITE, но в конце транзакции увеличивает значение поля @Version, даже если фактически сущность не изменилась.\n Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.\n\n
Оптимистичное блокирование - подход предполагает, что параллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им свободно выполнять любые чтения и обновления данных. Но при окончании транзакции производится проверка, изменились ли данные в ходе выполнения данной транзакции и, если да, транзакция обрывается и выбрасывается OptimisticLockException. Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии:\n @Version\n private long version;\n Поле, аннотирование @Version, может быть целочисленным или временнЫм. При завершении транзакции, если сущность была заблокирована оптимистично, будет проверено, не изменилось ли значение @Version кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто OptimisticLockException. Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности. Позволяет отказатьсь от блокировок на уровне БД и делать всё с JPA.\n\n
Пессимистичное блокирование - подход напротив, ориентирован на транзакции, которые часто конкурируют за одни и те же данные и поэтому блокирует доступ к данным в тот момент когда читает их. Другие транзакции останавливаются, когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или кидают исключение). Пессимистичное блокирование выполняется на уровне базы и поэтому не требует вмешательств в код сущности.\n\n
Блокировки ставятся путём вызова метода lock() у EntityManager, в который передаётся сущность, требующая блокировки и уровень блокировки:\n EntityManager em = entityManagerFactory.createEntityManager();\n em.lock(company1, LockModeType.OPTIMISTIC);',
        'HIBERNATE_JDBC', true),
       ('Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?', '1. first-level cache (кэш первого уровня) — кэширует данные одной транзакции;\n 2. second-level cache (кэш второго уровня) — кэширует данные транзакций от одной фабрики сессий. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня.\n 3. Кэш запросов.\n\n
Кэш первого уровня – это кэш сессии (Session), который является обязательным, это и есть PersistenceContext. Через него проходят все запросы. В том случае, если мы выполняем несколько обновлений объекта, Hibernate старается отсрочить (насколько это возможно) обновление этого объекта для того, чтобы сократить количество выполненных запросов в БД. Например, при пяти истребованиях одного и того же объекта из БД в рамках одного persistence context, запрос в БД будет выполнен один раз, а остальные четыре загрузки будут выполнены из кэша. Если мы закроем сессию, то все объекты, находящиеся в кэше, теряются, а далее – либо сохраняются в БД, либо обновляются.\n\n
Особенности кэша первого уровня:\n ❖ включен по умолчанию, его нельзя отключить;\n ❖ связан с сессией (контекстом персистентности), то есть разные сессии видят только объекты из своего кэша, и не видят объекты, находящиеся в кэшах других сессий;\n ❖ при закрытии сессии PersistenceContext очищается - кэшированные объекты, находившиеся в нем, удаляются;\n ❖ при первом запросе сущности из БД, она загружается в кэш, связанный с этой сессией;\n ❖ если в рамках этой же сессии мы снова запросим эту же сущность из БД, то она будет загружена из кэша, и никакого второго SQL-запроса в БД сделано не будет;\n ❖ сущность можно удалить из кэша сессии методом evict(), после чего следующая попытка получить эту же сущность повлечет обращение к базе данных;\n ❖ метод clear() очищает весь кэш сессии.\n\n
Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту-фабрике сессий (Session Factory object) и, следовательно, кэш второго уровня доступен одновременно в нескольких сессиях или контекстах персистентности. Кэш второго уровня требует некоторой настройки и поэтому не включен по умолчанию. Настройка кэша заключается в конфигурировании реализации кэша и разрешения сущностям быть закэшированными. Hibernate не реализует сам никакого in-memory сache, а использует существующие реализации кэшей.',
        'HIBERNATE_JDBC', false),
       ('Как работать с кешем 2 уровня?', 'Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.\n Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan.\n\n
В Hibernate кэширование второго уровня реализовано в виде абстракции, то есть мы должны предоставить любую её реализацию, вот несколько провайдеров: Ehcache, OSCache, SwarmCache, JBoss TreeCache.\n Для Hibernate требуется только реализация интерфейса org.hibernate.cache.spi.RegionFactory, который инкапсулирует все детали, относящиеся к конкретным провайдерам. По сути, RegionFactory действует как мост между Hibernate и поставщиками кэша. В примерах будем использовать Ehcache. Что нужно сделать: ❖ добавить мавен-зависимость кэш-провайдера нужной версии ❖ включить кэш второго уровня и определить конкретного провайдера hibernate.cache.use_second_level_cache=true hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory ❖ установить у нужных сущностей JPA-аннотацию @Cacheable, обозначающую, что сущность нужно кэшировать, и Hibernate-аннотацию @Cache, настраивающую детали кэширования, у которой в качестве параметра указать стратегию параллельного доступа" на "Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня. Hibernate поставляется со встроенной поддержкой стандарта кэширования Java JCache, а также двух популярных библиотек кэширования: Ehcache и Infinispan. Shared Cache Mode  ENABLE_SELECTIVE,  ALL, NONE, UNSPECIFIED',
        'HIBERNATE_JDBC', false),
       ('Что такое JPQL/HQL и чем он отличается от SQL?', 'Hibernate Query Language (HQL) и Java Persistence Query Language (JPQL) - оба являются объектно-ориентированными языками запросов, схожими по природе с SQL.\n  JPQL - это подмножество HQL.\nn\
HQL - это язык запросов, практически такой же как SQL, однако, вместо имен и колонок таблиц базы данных, он использует имена классов Entity и их атрибуты. В качестве параметров запросов также используются типы данных атрибутов Entity, а не полей баз данных. В отличии от SQL в JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования. В JPA запрос представлен в виде javax.persistence.Query или javax.persistence.TypedQuery, полученных из EntityManager.\n\n
В Hibernate HQL-запрос представлен org.hibernate.query.Query, полученный из Session. Если HQL является именованным запросом, то будет использоваться Session#getNamedQuery, в противном случае требуется Session#createQuery.',
        'HIBERNATE_JDBC', false),
       ('Что такое Criteria API и для чего он используется?', 'JPA Criteria API - это API, который позволяет делать WHERE (SELECT) запросы гораздо проще. (Динамические запросы).\n  Основные преимущества JPA Criteria API:\n ❖ ошибки могут быть обнаружены во время компиляции;\n ❖ позволяет динамически формировать запросы на этапе выполнения приложения.\n\n Основные недостатки:\n ❖ нет контроля над запросом, сложно отловить ошибку\n ❖ влияет на производительность, множество классов\n  Для динамических запросов - фрагменты кода создаются во время выполнения - JPA Criteria API является предпочтительней.\n\n
Вот некоторые области применения Criteria API:\n * Criteria API поддерживает проекцию, которую мы можем использовать для агрегатных функций вроде sum(), min(), max() и т.д.\n * Criteria API может использовать ProjectionList для извлечения данных только из выбранных колонок./n * Criteria API может быть использована для join запросов с помощью соединения нескольких таблиц, используя методы createAlias(), setFetchMode() и setProjection()./n * Criteria API поддерживает выборку результатов согласно условиям (ограничениям). Для этого используется метод add() с помощью которого добавляются ограничения (Restrictions)./n * Criteria API позволяет добавлять порядок (сортировку) к результату с помощью метода addOrder().',
        'HIBERNATE_JDBC', false),
       ('Расскажите про проблему N+1 Select и путях ее решения.', 'Проблема N+1 запросов возникает, когда получение данных из БД выполняется за N дополнительных SQL-запросов для извлечения тех же данных, которые могли быть получены при выполнении основного SQL-запроса.\n Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.\n Чем больше значение N, тем больше запросов будет выполнено и тем больше влияние на производительность. И хотя лог медленных запросов может вам помочь найти медленные запросы, но проблему N + 1 он не обнаружит, так как каждый отдельный дополнительный запрос выполняется достаточно быстро.\n  Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.\n\n
1. JOIN FETCH И при FetchType.EAGER и при FetchType.LAZY нам поможет JPQL-запрос с JOIN FETCH. Опцию «FETCH» можно использовать в JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе вместо дополнительных запросов для каждого доступа к ленивым полям объекта.\n Лучший вариант решения для простых запросов (1-3 уровня вложенности связанных объектов).\n  select pc\n     from PostComment pc\n    join fetch pc.post p\n\n
2. EntityGraph\n В случаях, когда нам нужно получить по-настоящему много данных, и у нас jpql запрос - лучше всего использовать EntityGraph.\n\n
3. @Fetch(FetchMode.SUBSELECT)\n Аннотация Hibernate. Можно использовать только с коллекциями. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций:\n  @Fetch(value = FetchMode.SUBSELECT)\n  private Set<Order> orders = new HashSet<>();\n\n
4. Batch fetching\n Это Аннотация Hibernate, в JPA её нет. Указывается над классом сущности или над полем коллекции с ленивой загрузкой. Будет сделан один sql-запрос для получения корневых сущностей и, если в контексте персистентности будет обращение к ленивым полям-коллекциям, то выполнится еще один запрос для получения связанных коллекций. Количество загружаемых сущностей указывается в аннотации.\n  @BatchSize(size=5)\n private Set<Order> orders = new HashSet<>();\n\n
5. HibernateSpecificMapping, SqlResultSetMapping Для нативных запросов рекомендуется использовать именно их.
', 'HIBERNATE_JDBC', true),
       ('Что такое Entity Graph', 'Он позволяет определить шаблон путем группировки связанных полей, которые мы хотим получить, и позволяет нам выбирать тип графа во время выполнения.Основная цель JPA Entity Graph - улучшить производительность в рантайме при
загрузке базовых полей сущности и связанных сущностей и коллекций.\n Вкратце, Hibernate загружает весь граф в одном SELECT-запросе, то есть все указанные связи от нужной нам сущности. . Работа с EntityGraph: createEntityGraph, getEntityGraph.',
        'HIBERNATE_JDBC', true),
       ('Что такое «шаблон проектирования»?', 'Проверенное и готовое к использованию логическое решение, которе может быть реализовано по-разному в разных языках программирования.\n\n
Плюсы:\n\n
снижение сложности разработки за счёт готовых абстракций\n\n
облегчение коммуникации между разработчиками\n\n
Минусы:\n\n
слепое следование некоторому шаблону может привести к усложнению программы.\n\n
желание попробовать некоторый шаблон в деле без особых на то оснований.', 'PATTERNS_ALGORITHMS', false),
       ('Назовите основные характеристики шаблонов.', 'Имя - все шаблоны имеют уникальное имя, служащее для их идентификации;\n\n
Назначение данного шаблона;\n\n
Задача, которую шаблон позволяет решить;\n\n
Способ решения, предлагаемый в шаблоне для решения задачи в том контексте, где этот шаблон был найден;\n\n
Участники - сущности, принимающие участие в решении задачи;\n\n
Следствия от использования шаблона как результат действий, выполняемых в шаблоне;\n\n
Реализация - возможный вариант реализации шаблона.', 'PATTERNS_ALGORITHMS', false),
       ('Назовите три основные группы паттернов.', 'Порождающие - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов без внесения в программу лишних зависимостей.\n\n
Структурные - отвечают за построение удобных в поддержке иерархий классов\n\n
Поведенческие - заботятся об эффективной коммуникации между объектами.\n\n
Основные - основные строительные блоки, используемые для построения других шаблонов. Например, интерфейс.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Одиночка (Singleton).', 'Порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.\n\n
Конструктор помечается как private, а для создания нового объекта Singleton использует специальный метод getInstance(). Он либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.\n\n
private static Singleton instance;\n\n
    \tpublic static Singleton getInstance() {\n
        \t\tif (instance == null) {\n
           \t\t\tinstance = new Singleton(); \n
        \t\t}\n
        \t\treturn instance;\n
}\n\n
+ : можно не создавать множество объектов для ресурсоемких задач, а пользоваться одним\n\n
- : нарушает принцип единой ответственности, так как его могут использовать множество объектов\n\n
Почему считается антипаттерном?\n\n \t- Нельзя тестировать с помощью mock, но можно использовать powerMock.\n \t- Нарушает принцип единой ответственности\n \t- Нарушает Open/Close принцип, его нельзя расширить',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Строитель (Builder).', 'Порождающий паттерн, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений одного объекта.\n\n
Паттерн предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.\n\n
Процесс конструирования объекта разбить на отдельные шаги (например, построитьСтены, вставитьДвери). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.\n\n
Можно пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.\n\n
+: Позволяет использовать один и тот же код для создания различных объектов. Изолирует сложный код сборки объектов от его основной бизнес-логики.\n\n
-: Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Фабричный метод (Factory Method).', 'Порождающий шаблон проектирования, в котором предоставляет интерфейс для создания объектов в родительском классе,  но позволяет подклассам изменять тип создаваемых объектов.\n\n подклассы имплементируют общий интерфейс с методом для создания объектов. Переопределенный метод в каждом наследнике возвращает нужный вариант объекта.\n\n
Объекты всё равно будут создаваться при помощи new, но делать это будет фабричный метод. Таким образом можно переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.\n\n
Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.\n\n
+: Выделяет код производства объектов в одно место, упрощая поддержку кода. Реализует принцип открытости/закрытости.\n\n
- : Может привести к созданию больших параллельных иерархий классов, так как для каждого класса продукта надо создать свой подкласс создателя.\n\n Пример: у нас есть интерфейс "разработичк" и его реализация в виде классов "разработчиков" но под каждую реализацию нужно создать производителя для этого создаем еще один интерфейс который будет имень всего один фабричный метод.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Абстрактная фабрика (Abstract Factory).', 'Порождающий паттерн проектирования, Абстрактная фабрика задаёт интерфейс создания всех доступных типов продуктов, а каждая конкретная реализация фабрики порождает продукты одной из вариаций.\n\n
Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.\n\n
Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит фабричные методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые мы выделили ранее — Кресла, Диваны и Столики.\n\n
+: гарантированно будет создаваться тип одного семейства\n\n
- : Усложняет код программы из-за введения множества дополнительных классов.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Прототип (Prototype).', 'Порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.\n\n
Паттерн поручает создание копий самим копируемым объектам. Он вводит общий интерфейс с методом clone для всех объектов, поддерживающих клонирование. Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта.интерфейс Cloneable - является реализацией шаблона портотип\n\n
+: Позволяет клонировать объекты, не привязываясь к их конкретным классам.\n\n
- : Сложно клонировать составные объекты, имеющие ссылки на другие объекты.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Адаптер (Adapter).', 'Структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.\n\n
Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.\n\n
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого.\n\n
+: Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.\n\n
- : Усложняет код программы из-за введения дополнительных классов.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Декоратор (Decorator).', 'Структурный паттерн проектирования, который позволяет добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».\n\n(Надстройка когда уже есть готовый функционал(класс) и мы хотим вызывать этот же функционал но с добавлением своей реализации)\n\n
Целевой объект помещается в другой объект-обёртку, который запускает базовое поведение обёрнутого объекта, а затем добавляет к результату что-то своё.\n\n
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.\n\n
Адаптер не менят состояния объекта, а декоратор может менять.\n\n
+: Большая гибкость, чем у наследования.\n\n
- : Труднее конфигурировать многократно обёрнутые объекты.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Заместитель (Proxy).', 'Структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители, которые перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.\n\n
Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта, выполняя промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте.\n\n
+: Позволяет контролировать сервисный объект незаметно для клиента.\n\n
- : Увеличивает время отклика от сервиса.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Итератор (Iterator).', 'Поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.\n\n
Идея состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.\n\n
Детали: Создается итератор и интерфейс, который возвращает итератор. В классе, в котором надо будет вызывать итератор, имплементируем интерфейс, возвращающий итератор, а сам итератор делаем там нестатическим вложенным классом, так как он нигде использоваться больше не будет.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Шаблонный метод (Template Method).', 'Поведенческий паттерн проектирования,это метод, внутренние блоки которого могут переопределяться подклассами для избежания повторного копирования ( который пошагово определяет алгоритм и позволяет наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом).\n\n
Паттерн предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом. Для описания шагов используется абстрактный класс. Общие шаги можно будет описать прямо в абстрактном класе. Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility).', 'Поведенческий паттерн проектирования, позволяет передавать запрос по цепочке потенциальных обработчиков, пока один из них не обработает запрос. Каждый обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи  Область применения цепочки обязанностей — всевозможные обработчики событий, последовательные проверки доступа и прочее.\n\n
Базируется на том, чтобы превратить каждую проверку в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.\n\n
Каждый из методов будет иметь ссылку на следующий метод-обработчик, что образует цепь. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке. Может и не передавать, если проверка в одном из методов не прошла, например.',
        'PATTERNS_ALGORITHMS', false),
       ('Какие паттерны используются в Spring Framework?', 'Singleton - Bean scopes\n\n
Factory - Bean Factory classes\n\n
Prototype - Bean scopes\n\n
Adapter - Spring Web and Spring MVC\n\n
Proxy - Spring Aspect Oriented Programming support\n\n
Template Method - JdbcTemplate, HibernateTemplate etc\n\n
Front Controller - Spring MVC DispatcherServlet\n\n
DAO - Spring Data Access Object support\n\n
Dependency Injection', 'PATTERNS_ALGORITHMS', false),
       ('Какие паттерны используются в Hibernate?', 'Domain Model – объектная модель предметной области, включающая в себя как поведение так и данные.\n\n
Data Mapper – слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.\n\n
Proxy  — применяется для ленивой загрузки.\n\n
Factory — используется в SessionFactory', 'PATTERNS_ALGORITHMS', false),
       ('Шаблоны GRASP: Low Coupling (низкая связанность) и High Cohesion (высокая сплоченность)', 'Low Coupling - части системы, которые изменяются вместе, должны находиться близко друг к другу. Необходимо распределить ответственности между классами так, чтобы обеспечить минимальную связанность.\n\n
High Cohesion - если возвести Low Coupling в абсолют, то можно прийти к тому, чтобы разместить всю функциональность в одном единственном классе.классы должны содержать связанную бизнес — логику. В таком случае связей не будет вообще, но что-то тут явно не так, ведь в этот класс попадет совершенно несвязанная между собой бизнес-логика. Принцип High Cohesion говорит следующее: части системы, которые изменяются параллельно, должны иметь как можно меньше зависимостей друг на друга.\n\n
Low Coupling и High Cohesion представляют из себя два связанных между собой паттерна, рассматривать которые имеет смысл только вместе. Их суть: система должна состоять из слабо связанных классов, которые содержат связанную бизнес-логику. Соблюдение этих принципов позволяет удобно переиспользовать созданные классы, не теряя понимания о их зоне ответственности.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про паттерн Saga', 'Сага — это механизм, обеспечивающий согласованность данных в микросервисах без применения распределенных транзакций.\n\n
Для каждой системной команды, которой надо обновлять данные в нескольких сервисах, создается некоторая сага. Сага представляет из себя некоторый «чек-лист», состоящий из последовательных локальных ACID-транзакций, каждая из которых обновляет данные в одном сервисе. Для обработки сбоев применяется компенсирующая транзакция. Такие транзакции выполняются в случае сбоя на всех сервисах, на которых локальные транзакции выполнились успешно.\n\n
Типов транзакций в саге четыре:\n\n
Компенсирующая — отменяет изменение, сделанное локальной транзакцией.\n\n
Компенсируемая — это транзакция, которую необходимо компенсировать (отменить) в случае, если последующие транзакции завершаются неудачей.\n\n
Поворотная — транзакция, опеределяющая успешность всей саги. Если она выполняется успешно, то сага гарантированно дойдет до конца.\n\n
Повторяемая — идет после поворотной и гарантированно завершается успехом.', 'PATTERNS_ALGORITHMS', false),
       ('Change Data Capture', 'Change Data Capture (CDC) - это паттерн проектирования, который позволяет отслеживать и фиксировать изменения, происходящие в данных базы данных, и передавать эти изменения в другие системы или службы.\n\n
Основные характеристики CDC:\n\n
1.Непрерывное отслеживание изменений: CDC постоянно следит за изменениями в базе данных, фиксируя операции добавления, изменения и удаления данных.\n\n
2.Минимальные нарушения основных операций: CDC выполняет свою работу, не влияя на нормальную работу приложений, которые взаимодействуют с базой данных.\n\n
3.Передача изменений в другие системы: Собранные CDC-системой изменения данных передаются в другие системы, такие как хранилища данных, аналитические платформы или системы репликации.\n\n
4.Различные источники данных: CDC может работать с разными типами баз данных, включая реляционные, NoSQL и другие.',
        'PATTERNS_ALGORITHMS', false),
       ('Event Sourcing', 'Event Sourcing - это паттерн проектирования, используемый для построения систем, в которых источником истины являются события, описывающие изменения состояния системы во времени.\n\n
Основные характеристики Event Sourcing:\n\n
1.Событийная модель: Вместо хранения текущего состояния объекта, Event Sourcing фокусируется на хранении последовательности событий, которые привели к данному состоянию.\n\n
2.Неизменяемость событий: События, записанные в системе, являются неизменяемыми. Новое состояние объекта создается путем применения новых событий к текущему состоянию.\n\n
3.Восстановление состояния: Текущее состояние объекта может быть восстановлено путем применения всех сохраненных событий, начиная с начального состояния.\n\n
4.Асинхронность и событийная модель: Событийная природа Event Sourcing хорошо сочетается с асинхронной обработкой данных и событийно-ориентированной архитектурой.',
        'PATTERNS_ALGORITHMS', false),
       ('Transactional outbox', 'Transactional Outbox - это паттерн проектирования, используемый в распределенных системах для обеспечения надежной доставки событий между различными сервисами.\n\n
Основные характеристики Transactional Outbox:\n\n
1.Двухфазная фиксация: Транзакции, изменяющие состояние системы, также записывают события в локальную "исходящую" очередь (outbox). Таким образом, изменения данных и публикация событий происходят в рамках одной транзакции.\n\n
2.Асинхронная обработка: Отдельный процесс периодически извлекает события из локальной очереди и публикует их в сторонние системы или сервисы-подписчики.\n\n
3.Отказоустойчивость: Если при публикации события возникает ошибка, оно остается в локальной очереди и будет повторно обработано при следующем цикле.\n\n
4.Идемпотентность: События, публикуемые из транзакционной очереди, должны быть идемпотентными, чтобы подписчики могли корректно обрабатывать повторные события.',
        'PATTERNS_ALGORITHMS', false),
       ('Что такое Big O? Как происходит оценка асимптотической сложности алгоритмов?', 'Big O нотация нужна для описания сложности алгоритмов.Сложность алгоритма состоит из двух факторов: временная сложность и сложность по памяти.\n\n
Основные виды сложности:\n\n
- **Константная сложность O(1)**: Количество операций не зависит от размера входных данных.\n\n
- **Линейная сложность O(n)**: Количество операций линейно зависит от размера входных данных.\n\n
- **Логарифмическая сложность O(log n)**: Количество операций растет логарифмически с ростом размера входных данных.\n\n
- **Квадратичная сложность O(n^2)**: Количество операций пропорционально квадрату размера входных данных.\n\n
- **Экспоненциальная сложность O(2^n)**: Количество операций растет экспоненциально с ростом размера входных данных.',
        'PATTERNS_ALGORITHMS', false),
       ('Что такое рекурсия? Сравните преимущества и недостатки итеративных и рекурсивных алгоритмов. С примерами.', 'Рекурсия - это процесс, при котором функция или метод вызывает сам себя для решения некоторой подзадачи. Рекурсия состоит из базового случая и шага рекурсии. Базовый случай представляет собой самую простую задачу, которая решается за одну итерацию, например, if(n == 0) return 1.\n\n
В базовом случае обязательно  присутствует условие выхода из рекурсии; \n\n
Преимущества рекурсивных алгоритмов:\n\n
1.**Простота и читаемость**: Рекурсивные решения часто более компактны и читабельны, особенно для задач, которые естественно представляются в рекурсивной форме.\n\n
2.**Естественное выражение идеи**: Многие задачи, такие как обход дерева или вычисление факториала, могут быть естественно выражены и решены рекурсивно.\n\n
3.**Избегание явного управления состоянием**: Рекурсивные алгоритмы позволяют избежать необходимости явно управлять состоянием, так как состояние инкапсулируется в стеке вызовов.\n\n
Недостатки рекурсивных алгоритмов:\n\n
1.**Повышенное потребление памяти**: Каждый рекурсивный вызов добавляет новый уровень в стек вызовов, что может привести к высокому потреблению памяти для глубоких рекурсий.\n\n
2.**Возможность переполнения стека**: Если глубина рекурсии слишком велика, то это может привести к переполнению стека и ошибке времени выполнения.\n\n
3.**Более высокие накладные расходы**: Вызовы функций и возвраты из них сопряжены с накладными расходами, которые могут быть выше, чем у итеративных алгоритмов.',
        'PATTERNS_ALGORITHMS', false),
       ('Что такое жадные алгоритмы? Приведите пример.', 'Жадные алгоритмы являются одной из 3х техник создания алгоритмов, вместе с принципом "Разделяй и властвуй" и динамическим программированием.\n\n
Жадный алгоритм - это алгоритм, который на каждом шагу совершает локально оптимальные решения, т.е. максимально возможное из допустимых, не учитывая предыдущие или следующие шаги. Последовательность этих локально оптимальных решений приводит (не всегда) к глобально оптимальному решению.\n\n
Т.е. задача рабивается на подзадачи, в каждой подзадаче делается оптимальное решение и, в итоге, вся задача решается оптимально. При этом важно является ли каждое локальное решение безопасным шагом. Безопасный шаг - приводящий к оптимальному решению.\n\n
К примеру, алгоритм Дейкстры нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про пузырьковую сортировку.', 'Будем идти по массиву слева направо. Если текущий элемент больше следующего, меняем их местами. Делаем так, пока массив не будет отсортирован.\n\n
Aсимптотика в худшем и среднем случае – O(n^2), в лучшем случае – O(n) - массив уже отсортирован.  ',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про быструю сортировку.', 'Выберем некоторый опорный элемент(pivot). После этого перекинем все элементы, меньшие его, налево, а большие – направо. Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot. Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot. В итоге получим отсортированный массив, так как каждый элемент меньше опорного стоял раньше каждого большего опорного.\n\n
Асимптотика: O(n*log(n)) в среднем и лучшем случае. Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента. ',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про сортировку слиянием.',
        'Основана на парадигме «разделяй и властвуй». Будем делись массив пополам, пока не получим множество массивов из одного элемента. После чего выполним процедуру слияния: поддерживаем два указателя, один на текущий элемент первой части, второй – на текущий элемент второй части. Из этих двух элементов выбираем минимальный, вставляем в ответ и сдвигаем указатель, соответствующий минимуму. Так сделаем слияния массивов из 1го элемента в массивы по 2 элемента, затем из 2х в 4 и т.д. Слияние работает за O(n), уровней всего log(n), поэтому асимптотика O(n*log(n)). ',
        'PATTERNS_ALGORITHMS', false),
       ('Расскажите про бинарное дерево.', 'Бинарное дерево - иерархическая структура данных, в которой каждый узел может иметь двух потомков. Как правило, первый называется родительским узлом, а наследники называются левым и правым нодами/узлами. Каждый узел в дереве задаёт поддерево, корнем которого он является. Оба поддерева — левое и правое — тоже являются бинарными деревьями. Ноды, которые не имеют потомков, называются листьями дерева. У всех узлов левого поддерева произвольного узла X значения ключей данных меньше, нежели значение ключа данных самого узла X. У всех узлов правого поддерева произвольного узла X значения ключей данных больше либо равны, нежели значение ключа данных самого узла X. Этим достигается упорядоченная структура данных, то есть всегда отсортированная.\n\n
Поиск в лучшем случае - O(log(n)), худшем - O(n) -  при вырождении в связанный список.', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про красно-черное дерево.', 'Усовершенствованная версия бинарного дерева. Каждый узел в к/ч дереве имеет дополнительное поле - цвет. К/ч дерево отвечает следующим требованиям:\n\n
1) Узел либо красный, либо черный.\n\n
2) Корень - черный.\n\n
3) Все листья - черные и не хранят данных.\n\n
4) Оба потомка каждого красного узла - черные.\n\n
5) Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число черных узлов. Если не одинаковое, то происходит переворот.\n\n
При добавлении постоянно увеличивающихся/уменьшающихся чисел в бинарное дерево, оно вырождается в связанный список и теряет свои преимущества. Тогда как к/ч дерево может потребовать до двух поворотов для поддержки сбалансированности, чтобы избежать вырождения.\n\n
При операциях удаления в бинарном дереве для удаляемого узла надо найти замену. К/ч дерево сделает тоже самое, но потребует до трёх поворотов для поддержки сбалансированности.\n\n
В этом и состоит преимущство.\n\n
Сложность поиска, вставки и удаления — O(log(n))', 'PATTERNS_ALGORITHMS', false),
       ('Расскажите про линейный и бинарный поиск.', 'Линейный поиск - сложность O(n), так как все элементы проверяются по очереди.\n\n
Бинарный поиск - O(log(n)). Массив должен быть отсортирован. Происходит поиск индекса в массиве, содержащего искомое значение.\n\n
1) Берем значение из середины массива и сраваем с искомым. Индекс середины считается по формуле mid = (high + low) / 2\n\n
low - индекс начала левого подмассива, high - индекс конца правого подмассива.\n\n
2) Если значение в середине больше искомого, то рассматриваем левый подмассив и high = middle - 1\n\n
3) Если меньше, то правый и low = middle + 1\n\n
4) Повторяем, пока mid не страновится равен искомому элементу или подмассив не станет пустым.', 'PATTERNS_ALGORITHMS',
        false),
       ('Что такое инверсия контроля (IoC) и внедрение зависимостей (DI)? Как эти принципы реализованы в Spring?', '### Инверсия контроля (IoC)\n
IoC — это принцип дизайна, согласно которому управление объектами и их зависимостью передается фреймворку или контейнеру, а не управляется в коде напрямую. Это позволяет снизить связанность между компонентами и сделать систему более модульной и легкой для тестирования.\n\n

### Внедрение зависимостей (DI)\n
DI — это конкретная техника реализации IoC, которая подразумевает, что зависимости объекта (например, другие объекты, от которых он зависит) внедряются ему извне, обычно через конструктор, поле или сеттер.\n\n

### Реализация в Spring\n

\t1. Контейнер IoC\n
Spring предоставляет контейнер IoC, который управляет жизненным циклом объектов и зависимостями между ними. Контейнер создаёт объекты, конфигурирует их и связывает, автоматически вызывая нужные методы, когда это необходимо.\n\n

\t2. Виды внедрения зависимостей\n
Spring поддерживает три основных способа внедрения зависимостей:\n
\t- Через конструктор (Constructor Injection): зависимости передаются через параметры конструктора класса.\n
\t- Через сеттеры (Setter Injection): зависимости передаются через методы-сеттеры.\n
\t- Через поля (Field Injection): зависимости внедряются напрямую в поля класса с использованием аннотации @Autowired.)',
        'SPRING', true),
       ('Что такое IoC контейнер?', '\tЭто объект, который занимается созданием других объектов и внедрением в них зависимостей, а также за управление их жизненным циклом.\n

\tIoC container - является Map, ключом которого является String (уникальный id - имя бина), а значением - сам объект со всеми его зависимостями.\n

\tПредставлен интерфейсами ApplicationContext и BeanFactory.\n

\tSpring Framework предоставляет несколько реализаций интерфейса ApplicationContext:\n

\t\t- ClassPathXmlApplicationContext и FileSystemXmlApplicationContext - для автономных приложений;\n
\t\t- WebApplicationContext - для веб-приложений;\n
\t\t- AnnotationConfigApplicationContext - для обычной Java-конфигурации, в качестве аргумента которому передается класс, либо список классов с аннотацией @Configuration, либо с любой другой аннотацией JSR-330, в том числе и @Component.\n

\tКонтейнер получает инструкции о том, какие объекты создавать, настраивать и собирать, через метаданные конфигурации, которые представлены в виде XML, Java-аннотаций или Java-кода',
        'SPRING', true),
       ('Расскажите про ApplicationContext и BeanFactory, чем отличаются? В каких случаях что стоит использовать?', 'ApplicationContext является наследником BeanFactory и полностью реализует его функционал, добавляя больше специфических enterprise-функций. Может работать с бинами всех скоупов.\n\n
BeanFactory - это фактический контейнер, который создает, настраивает и управляет рядом bean-компонентов. Эти бины обычно взаимодействуют друг с другом и, таким образом, имеют зависимости между собой. Эти зависимости отражены в данных конфигурации, используемых BeanFactory. Может работать с бинами singleton и prototype.\n\n
BeanFactory обычно используется тогда, когда ресурсы ограничены (мобильные устройства), так как он легче по сравнению с ApplicationContext. Поэтому, если ресурсы не сильно ограничены, то лучше использовать ApplicationContext.\n\n
ApplicationContext загружает все бины при запуске, а BeanFactory по требованию. ', 'SPRING', false),
       ('Расскажите про аннотацию @Bean?', 'Используется над !методом! для указания того, что данный метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером. Такие методы можно использовать как в классах с аннотацией @Configuration, так и в классах с аннотацией @Component (или её наследниках).\n\n
Позволяет дополнительно определить у бина:\n
\t- name - имя (уникальный идентификатор) бина;\n
\t- initMethod - имя метода для вызова во время инициализации бина;\n
\t- destroyMethod - имя метода для вызова во время удаления бина из контекста;\n
\t- autowireCandidate - является ли этот бин кандидатом на автоматическое внедрение в другой бин.', 'SPRING', true),
       ('Расскажите про аннотацию @Component?',
        'Аннотация @Component - помечаем ей класс чтобы Spring Framework создал бин из этого класса.Именно эту аннотацию ищет Spring когда сканирует наши классы. @Component имеет наследников: @Repository, @Service и @Controller, их также называют стереотипными аннотациями',
        'SPRING', true),
       ('Чем отличаются аннотации @Bean и @Component?',
        'Аннотация @Component (как и @Service и @Repository) используется для автоматического обнаружения и автоматической настройки бинов в ходе сканирования путей к классам.\n\n Аннотация @Bean используется для явного объявления бина, а не для того, чтобы Spring делал это автоматически в ходе сканирования путей к классам',
        'SPRING', false),
       ('Расскажите про аннотации @Service и @Repository. Чем они отличаются?', ' @Repository - указывает, что класс используется для работы с поиском, получением и хранением данных. Аннотация может использоваться для реализации шаблона DАО.\n\n
 @Service - указывает, что класс является сервисом для реализации бизнес-логики.\n\n
Задача @Repository заключается в том, чтобы отлавливать определенные исключения персистентности и пробрасывать их как одно непроверенное исключение Spring Framework. Для этого в контекст должен быть добавлен класс PersistenceExceptionTranslationPostProcessor.',
        'SPRING', false),
       ('Расскажите про аннотацию @Autowired', ' @Autowired – автоматическое внедрение подходящего бина(конструктор, поле, сеттер-метод или метод конфигурации):\n
1) Контейнер определяет тип объекта для внедрения\n
2) Контейнер ищет соответствующий тип бина в контексте(он же контейнер)\n
3) Если есть несколько кандидатов, и один из них помечен как @Primary, то внедряется он\n
4) Если используется @Qualifier, то контейнер будет использовать информацию из @Qualifier, чтобы понять, какой компонент внедрять\n
5) В противном случае контейнер внедрит бин, основываясь на его имени или ID\n
6) Если ни один из способов не сработал, то будет выброшено исключение\n\n
Контейнер обрабатывает DI с помощью AutowiredAnnotationBeanPostProcessor. В связи с этим, аннотация не может быть использована ни в одном BeanFactoryPP или BeanPP.\n
В аннотации есть один параметр required = true/false - указывает, обязательно ли делать DI. По умолчанию true. Либо можно не выбрасывать исключение, а оставить поле c null, если нужный бин не был найден - false.\n
При циклической зависимости, когда объекты ссылаются друг на друга, нельзя ставить над конструктором.\n
    Однако при внедрении прямо в поля вы не предоставляете прямого способа создания экземпляра класса со всеми необходимыми зависимостями. Это означает, что:\n
    Существует способ (путем вызова конструктора по-умолчанию) создать объект с использованием new в состоянии, когда ему не хватает некоторых из его обязательных зависимостей, и использование приведет к NullPointerException\n
    Такой класс не может быть использован вне DI-контейнеров (тесты, другие модули) и нет способа кроме рефлексии предоставить ему необходимые зависимости\n
    Неизменность\n
В отличие от способа с использованием конструктора, внедрение через поля не может использоваться для присвоения зависимостей final-полям, что приводит к тому, что ваши объекты становятся изменяемыми',
        'SPRING', true),
       ('Расскажите про аннотацию @Resource', 'Аннотация @Resource пытается получить зависимость: по имени, по типу, затем по описанию (Qualifier). Имя извлекается из имени аннотируемого сеттера или поля, либо берется из параметра name.\n
    @Resource //По умолчанию поиск бина с именем "context"\n\n
    private ApplicationContext context;\n\
    @Resource(name="greetingService") //Поиск бина с именем "greetingService\n\n
    public void setGreetingService(GreetingService service) {\n
        this.greetingService = service;\n
    }\n\n
Разница с @Autowired:\n
❖ ищет бин сначала по имени, а потом по типу;\n
❖ не нужна дополнительная аннотация для указания имени конкретного бина;\n
❖ @Autowired позволяет отметить место вставки бина как необязательное @Autowired(required = false);\n
❖ при замене Spring Framework на другой фреймворк, менять аннотацию @Resource не нужно.', 'SPRING', false),
       ('Расскажите про аннотацию @Inject', 'Аннотация @Inject входит в пакет javax.inject и, чтобы её использовать, нужно добавить зависимость:\n\n
<dependency>\n
   <groupId>javax.inject</groupId>\n
   <artifactId>javax.inject</artifactId>\n
   <version>1</version>\n
</dependency>\n\n
@Inject (аннотация java) аналог @Autowired (аннотация spring) в первую очередь пытается подключить зависимость по типу, затем по описанию и только потом по имени. В ней нет параметров. Поэтому при использовании конкретного имени (Id) бина используем @Named:\n\n
@Inject\n
@Named("yetAnotherFieldInjectDependency")\n
private ArbitraryDependency yetAnotherFieldInjectDependency;', 'SPRING', false),
       ('Расскажите про аннотацию @Lookup', 'Обычно бины в приложении Spring являтся синглтонами, и для внедрения зависимостей мы используем конструктор или сеттер.\n\n
Но бывает и другая ситуация: имеется бин Car – синглтон (singleton bean), и ему требуется каждый раз новый экземпляр бина Passenger. То есть Car – синглтон, а Passenger – так называемый прототипный бин (prototype bean).\n Жизненные циклы бинов разные. Бин Car создается контейнером только раз, а бин Passenger создается каждый раз новый – допустим, это происходит каждый раз при вызове какого-то метода бина Car. Вот здесь то и пригодится внедрение бина с помощью Lookup метода. Оно происходит не при инициализации контейнера, а позднее: каждый раз, когда вызывается метод.\n Суть в том, что вы создаете метод-заглушку в бине Car и помечаете его специальным образом – аннотацией @Lookup. Этот метод должен возвращать бин Passenger, каждый раз новый.\n Контейнер Spring под капотом создаст прокси-подкласс и переопределит этот метод и будет нам выдавать новый экземпляр бина Passenger при каждом вызове аннотированного метода. Даже если в нашей заглушке он возвращает null (а так и надо делать - всё равно этот метод будет переопределен в прокси-подклассе)',
        'SPRING', false),
       ('Можно ли вставить бин в статическое поле? Почему?',
        'Spring не позволяет внедрять бины напрямую в статические поля. Это связано с тем, что когда загрузчик классов загружает статические значения, контекст Spring ещё не загружен.',
        'SPRING', false),
       ('Расскажите про аннотации @Primary и @Qualifier', '@Qualifier применяется если кандидатов для автоматического связывания несколько, она позволяет указать в качестве аргумента имя конкретного бина, который следует внедрить. Она может быть применена к отдельному полю класса, к отдельному аргументу метода или конструктора\n\n
@Primary тоже используется, чтобы отдавать предпочтение бину, когда есть несколько бинов одного типа, но в ней нельзя задать имя бина, она определяет значение по умолчанию, в то время как @Qualifier более специфичен. Если присутствуют аннотации @Qualifier и @Primary, то аннотация @Qualifier будет иметь приоритет.',
        'SPRING', false),
       ('Как заинжектить примитив?', 'Для этого можно использовать аннотацию @Value. Можно ставить над полем, конструктором, методом.\n
Такие значения можно получать из property файлов, из бинов, и т.п.\n\n
@Value("${some.key}")\n
public String stringWithDefaultValue;\n\n
В эту переменную будет внедрена строка, например из property или из view.\n
Кроме того, для внедрения значений мы можем использовать язык SpEL (Spring Expression Language)', 'SPRING', false),
       ('Как заинжектить коллекцию?', 'Если внедряемый объект массив, коллекция, или map с дженериком, то используя аннотацию @Autowired, Spring внедрит все бины подходящие по типу в этот массив(или другую структуру данных). В случае с map значениями будут сами бины, а ключами будут имена бинов:\n\n
Используя аннотацию @Qualifier можно настроить тип искомого бина.(Мы использовали параметр ''name'' у аннотации @Bean, чтобы указать конкретный классификатор для бина. Но элемент ''name'', на самом деле, является не столько именем, сколько идентификатором бина, который должен быть уникальным, потому что все бины хранятся в контейнере в Map. В случае с коллекцией мы хотим, чтобы несколько бинов имели одно и то же имя квалификатора, чтобы их можно было внедрить в одну коллекцию с одним и тем же квалификатором. В этом случае мы должны использовать аннотацию @Qualifier вместе с @Bean вместо элемента name.)\n\n
Бины могут быть упорядочены, когда они вставляются в списки (не Set или Map) или массивы. Поддерживаются как аннотация @Order, так и интерфейс Ordered.',
        'SPRING', false),
       ('Расскажите про аннотацию @Conditional', 'Spring предоставляет возможность на основе вашего алгоритма включить или выключить определение бина или всей конфигурации через @Conditional, в качестве параметра которой указывается класс, реализующий интерфейс Condition, с единственным методом matches(ConditionContext var1, AnnotatedTypeMetadata var2), возвращающий boolean.\n
Для создания более сложных условий можно использовать классы AnyNestedCondition, AllNestedConditions и NoneNestedConditions.\n\n
Аннотация @Conditional указывает, что компонент имеет право на регистрацию в контексте только тогда, когда все условия соответствуют.\n\n
Если класс @Configuration помечен как @Conditional, то на все методы @Bean, аннотации @Import и аннотации @ComponentScan, связанные с этим классом, также будут распространяться указанные условия.',
        'SPRING', false),
       ('Расскажите про аннотацию @Profile', 'Профили - это ключевая особенность Spring Framework, позволяющая нам относить наши бины к разным профилям (логическим группам), например, dev, test, prod.\n\n
Мы можем активировать разные профили в разных средах, чтобы загрузить только те бины, которые нам нужны.\n
Используя аннотацию @Profile, мы относим бин к конкретному профилю. Её можно применять на уровне класса или метода. Аннотация @Profile принимает в качестве аргумента имя одного или нескольких профилей. Она фактически реализована с помощью гораздо более гибкой аннотации @Conditional.\n
Ее можно ставить на @Configuration и Component классы. В Spring Boot есть возможность иметь один файл настроек application.properties, в котором будут основные настройки для всех профилей, и иметь по файлу настроек для каждого профиля application-dev.properties и application-prod.properties, содержащие свои собственные дополнительные настройки.',
        'SPRING', false),
       ('Расскажите про жизненный цикл бина, аннотации @PostConstruct и @PreDestroy()', 'I. Парсинг конфига, создание BeanDefinition\n
\t 4 способа парсинга:\n
\t - XML конфигурация\n
\t - Конфигурация через аннотации с указанием пакета для сканирования — AnnotationConfigApplicationContext(“package.name”)\n
\t - Конфигурация через аннотации с указанием класса помеченного аннотацией @Configuration - AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.\n
\t - Groovy конфигурация — GenericGroovyApplicationContext(“context.groovy”)\n
\t Все BeanDefinition кладутся в Map\n\n

II. Настройка созданных BeanDefinition\n
\tСуществует возможность повлиять на будущие бины. Для этого существует специальный интерфейс BeanFactoryPostProcessor, реализовав который, мы получаем доступ к созданным BeanDefinition и можем их изменять. (Например, происходит внедрения настроек подключения к базе данных из property файлов)\n\n

III. Создание экземпляров бинов\n
\t Созданием экземпляров бинов занимается BeanFactory. Экземпляры бинов создаются на основе ранее созданных BeanDefinition.\n\n

IV. Настройка созданных бинов\n
\t Происходит следующее:\n
\t 1. Pre-init:\n
\t\t — вызывается метод postProcessBeforeInitialization() всех имеющихся BeanPostProcessor-ов\n
\t\t — если у бина есть метод @PostConstruct, то вызывается и он\n
\t 2. Initialization:\n
\t\t — при наличии будет вызван метод, указанный в параметре initMethod аннотации @Bean.\n
\t\t — или стандартная инициализация\n
\t 3. Post-init:\n
\t\t — вызывается метод  postProcessAfterInitialization() всех имеющихся BeanPostProcessor-ов\n
\t\t — все бины в контейнере, у которого после этого вызывается метод refresh()\n
\t\t — можно донастроить бины ApplicationListener-ми\n\n

V. Бины готовы к использованию\n
\t — если нужно, получаем их вручную через ApplicationContext.getBean()\n\n

VI. Закрытие контекста, уничтожение бинов\n
\t — если у бина были методы @PreDestroy, destroy() (от интерфейса DisposibleBean), destroyMethod (из аннотации @Bean), то они будут вызваны до уничтожения бина\n
\t — бин уничтожен\n
\t — ApplicationContext.Close()\n\n
\t Бины бывают SCOPE_SINGLETON (инициализация произойдет один раз на этапе поднятия контекста) и SCOPE_PROTOTYPE (инициализация будет выполняться каждый раз по запросу)',
        'SPRING', true),
       ('Расскажите про скоупы бинов? Какой скоуп используется по умолчанию? Что изменилось в Spring 5?', 'Существует 2 области видимости по умолчанию.\n
* Singleton - область видимости по умолчанию. В контейнере будет создан только один бин, и все запросы на него будут возвращать один и тот же бин.\n
* Prototype - приводит к созданию нового бина каждый раз, когда он запрашивается.\n
Для бинов со scope “prototype” Spring не вызывает метод destroy(), так как не берет на себя контроль полного жизненного цикла этого бина. Spring не хранит такие бины в своём контексте ( контейнере), а отдаёт их клиенту и больше о них не заботится (в отличие от синглтон-бинов).\n\n
И 4 области видимости в веб-приложении.\n
* Request - Область видимости — 1 HTTP запрос. На каждый запрос создается новый бин\n
* Session - Область видимости — 1 сессия. На каждую сессию создается новый бин\n
* Application - Область видимости — жизненный цикл ServletContext\n
* WebSocket - Область видимости — жизненный цикл WebSocket\n
Жизненный цикл web csope полный.\n\n
В пятой версии Spring Framework не стало Global session scope. И появились Application и WebSocket', 'SPRING', true),
       ('Расскажите про аннотацию @ComponentScan', 'Аннотация @ComponentScan используется вместе с аннотацией @Configuration для указания пакетов, которые мы хотим сканировать на наличие компонентов, из которых нужно сделать бины.\n
@ComponentScan без аргументов указывает Spring по умолчанию сканировать текущий пакет и все его подпакеты. Текущий пакет - тот, в котором находится файл конфигурации с этой самой аннотацией @ComponentScan. В данном случае в контейнер попадут:\n
- бин конфигурационного класса;\n
- бины, объявленные в конфигурационном классе с помощью @Bean;\n
- все бины из пакета и его подпакетов.\n\n
Если  указать  @ComponentScan  с  атрибутом  basePackages,  то  это  изменит  пакет  по умолчанию на указанный\n
Если указать @ComponentScan с атрибутом excludeFilters, то это позволит использовать фильтр и исключить ненужные классы из процесса сканирования',
        'SPRING', false),
       ('Как спринг работает с транзакциями? Расскажите про аннотацию @Transactional.', 'Коротко:\n Spring создает прокси для всех классов, помеченных @Transactional (либо если любой из методов класса помечен этой аннотацией), что позволяет вводить транзакционную логику до и после вызываемого метода. При вызове такого метода происходит следующее:\n
- proxy, который создал Spring, создаёт persistence context (или соединение с базой),\n
- открывает в нём транзакцию и сохраняет всё это в контексте нити исполнения (натурально, в ThreadLocal).\n
- По мере надобности всё сохранённое достаётся и внедряется в бины.\n\n
Таким образом, если в вашем коде есть несколько параллельных нитей, у вас будет и несколько параллельных транзакций, которые будут взаимодействовать друг с другом согласно уровням изоляции.\n\n
Что произойдёт, если один метод с @Transactional вызовет другой метод с @Transactional?\n
Если это происходит в рамках одного сервиса, то второй транзакционный метод будет считаться частью первого, так как вызван у него изнутри, а так как спринг не знает о внутреннем вызове, то не создаст прокси для второго метода.(Обернуто в проски будет а вот транзакция создана не будет если из 2 класса вызван метод то транзакция будет)\n\n
Что произойдёт, если один метод БЕЗ @Transactional вызовет другой метод с @Transactional?\n
Так как spring не знает о внутреннем вызове, то не создаст прокси для второго метода.\n\n
Будет ли транзакция откачена, если будет брошено исключение, которое указано в контракте метода?\n
Если в контракте описано это исключение, то она не откатится. Unchecked исключения в транзакционном методе можно ловить, а можно и не ловить.\n\n
', 'SPRING', true),
       ('Какие есть атрибуты у @Transactional?', '1. propagation:\n
* REQUIRED — применяется по умолчанию. При входе в @Transactional метод будет использована уже существующая транзакция или создана новая транзакция, если никакой ещё нет\n
* REQUIRES_NEW — новая транзакция всегда создаётся при входе метод, ранее созданные транзакции приостанавливаются до момента возврата из метода.\n
* NESTED — корректно работает только с базами данных, которые умеют savepoints. При входе в метод в уже существующей транзакции создаётся savepoint, который по результатам выполнения метода будет либо сохранён, либо откачен. Все изменения, внесённые методом, подтвердятся только поздее, с подтверждением всей транзакции. Если текущей транзакции не существует, будет создана новая.\n
* MANDATORY — всегда используется существующая транзакция и кидается исключение, если текущей транзакции нет.\n
* SUPPORTS — метод с этим правилом будет использовать текущую транзакцию, если она есть, либо будет исполнятся без транзакции, если её нет.\n
* NOT_SUPPORTED — при входе в метод текущая транзакция, если она есть, будет приостановлена и метод будет выполняться без транзакции.\n
* NEVER — явно запрещает исполнение в контексте транзакции. Если при входе в метод будет существовать транзакция, будет выброшено исключение.\n\n
2. rollbackFor = Exception.class - если какой-либо метод выбрасывает указанное исключение, контейнер всегда откатывает текущую транзакцию. По умолчанию отлавливает RuntimeException\n\n
3. noRollbackFor = Exception.class - указание того, что любое исключение, кроме заданных, должно приводить к откату транзакции.\n
rollbackForClassName и noRollbackForClassName - для задания имен исключений в строковом виде.\n\n
4. readOnly - разрешает только операции чтения.\n
В свойстве transactionManager хранится ссылка на менеджер транзакций, определенный в конфигурации Spring.\n\n
5. timeOut - По умолчанию используется таймаут, установленный по умолчанию для базовой транзакционной системы. Сообщает менеджеру tx о продолжительности времени, чтобы дождаться простоя tx, прежде чем принять решение об откате не отвечающих транзакций.\n\n
6. isolation - уровень изолированности транзакций', 'SPRING', true),
       ('Как @Transactional работает под капотом?', 'В Spring Framework аннотация @Transactional работает с помощью AOP (Aspect-Oriented Programming) и управляет транзакциями путем создания прокси объектов вокруг методов, помеченных этой аннотацией. Под капотом происходит следующее:\n\n
1. Когда Spring создает бин, помеченный аннотацией @Transactional, он создает прокси-объект вокруг этого бина.\n
2. При вызове метода бина, который помечен @Transactional, прокси перехватывает вызов и запускает транзакцию до начала выполнения метода.\n
3. После выполнения метода, прокси обрабатывает результат метода и решает, нужно ли фиксировать изменения (COMMIT) или откатить транзакцию (ROLLBACK).\n
4. После завершения метода, транзакция завершается соответствующим образом в зависимости от результата метода.\n\n
Spring Framework использует менеджер транзакций для управления транзакциями и выполняет логику COMMIT или ROLLBACK в зависимости от конфигурации транзакций. Такой подход обеспечивает управление транзакциями в рамках бизнес-сервисов и методов, делая код более безопасным и надежным.',
        'SPRING', true),
       ('Как решить проблему N+1 с использованием @Transactional?', 'Использование аннотации @Transactional может помочь решить проблему N+1, указывая, что несколько операций с базой данных должны выполняться в рамках одной транзакции. Это гарантирует, что все данные будут извлечены в одном запросе, повышая производительность.\n\n
Вот пример использования @Transactional для устранения проблемы N+1:\n
@Transactional(readOnly = true)\n
public List<Order> findAllOrders() {\n
    return orderRepository.findAll();\n
}\n
В этом примере метод findAllOrders() помечен как @Transactional, что означает, что все операции с базой данных в рамках этого метода будут выполняться в одной транзакции. Это гарантирует, что запрос findAll() будет единственным запросом, выполненным для выборки всех заказов, устраняя проблему N+1.',
        'SPRING', true),
       ('Расскажите про аннотации @Controller и @RestController. Чем они отличаются?', '@Controller - специальный тип класса, обрабатывает HTTP-запросы и часто используется с аннотацией @RequestMapping.\n
@RestController ставится на класс-контроллер вместо @Controller. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций @Controller и @ResponseBody. Была введена в Spring 4.0 для упрощения создания RESTful веб-сервисов.\n\n
@ResponseBody сообщает контроллеру, что возвращаемый объект автоматически сериализуется (используя Jackson message converter) в json или xml и передается обратно в объект HttpResponse.',
        'SPRING', false),
       ('Что такое ResponseEntity?', 'ResponseEntity используется для формирования кастомизированного HTTP-ответа с пользовательскими параметрами (заголовки, код статуса и тело ответа). Во всех остальных случаях достаточно использовать @ResponseBody.\n
Если мы хотим использовать ResponseEntity, то просто должны вернуть его из метода, Spring позаботится обо всем остальном.\n
return ResponseEntity.status(213);', 'SPRING', false),
       ('Что такое ViewResolver?', 'ViewResolver  - распознаватель представлений - это способ работы с представлениями(html-файлы), который поддерживает их распознавание на основе имени, возвращаемого контроллером.\n\n
Spring Framework поставляется с большим количеством реализаций ViewResolver:\n- Например, класс UrlBasedViewResolver поддерживает прямое преобразование логических имен в URL.\n
- InternalResourceViewResolver — реализация ViewResolver по умолчанию, которая позволяет находить представления, которые возвращает контроллер для последующего перехода к ним. Ищет по заданному пути, префиксу, суффиксу и имени.\n\n
Любым реализациям ViewResolver желательно поддерживать интернационализацию, то есть множество языков.\n
Существует также несколько реализаций для интеграции с различными технологиями представлений, такими как FreeMarker (FreeMarkerViewResolver), Velocity (VelocityViewResolver) и JasperReports (JasperReportsViewResolver).',
        'SPRING', false),
       ('Чем отличаются Model, ModelMap и ModelAndView?', '1. Model - интерфейс, представляет коллекцию пар ключ-значение Map<String, Object>. Содержимое модели используется для отображения данных во View. Например, если View выводит информацию об объекте Customer, то она может ссылаться к ключам модели, например customerName, customerPhone, и получать значения для этих ключей. Объекты-значения из модели также могут содержать бизнес-логику.\n\n
2. ModelMap - класс, наследуется от LinkedHashMap, тоже используется для передачи значений для визуализации представления. Преимущество ModelMap заключается в том, что он дает нам возможность передавать коллекцию значений и обрабатывать эти значения, как если бы они были внутри Map.\n\n
3. ModelAndView - это просто контейнер для ModelMap, объект View и HttpStatus. Это позволяет контроллеру возвращать все значения как одно. View используется для отображения данных приложения пользователю. Spring MVC поддерживает несколько поставщиков View(они называются шаблонизаторы) — JSP, JSF, Thymeleaf, и т.п. Интерфейс View преобразует объекты в обычные сервлеты.',
        'SPRING', false),
       ('Расскажите про паттерн Front Controller, как он реализован в Spring?', 'Front controller - обеспечивает единую точку входа для всех входящих запросов. Все запросы обрабатываются одним обработчиком - DispatcherServlet с маппингом "/". Этот обработчик может выполнить аутентификацию, авторизацию, регистрацию или отслеживание запроса, а затем распределяет их между контроллерами, обрабатывающими разные URL. Это и есть реализация паттерна Front Controller. Веб-приложение может определять любое количество DispatcherServlet-ов. Каждый из них будет работать в своем собственном пространстве имен, загружая свой собственный дочерний WebApplicationContext с вьюшками, контроллерами и т.д.\n\n
❖ Один из контекстов будет корневым, а все остальные контексты будут дочерними.\n
❖ Все дочерние контексты могут получить доступ к бинам, определенным в корневом контексте, но не наоборот.\n
❖ Каждый дочерний контекст внутри себя может переопределить бины из корневого контекста.\n
WebApplicationContext расширяет ApplicationContext (создаёт и управляет бинами и т.д.), но помимо этого он имеет дополнительный метод getServletContext(), через который у него есть возможность получать доступ к ServletContext-у. ContextLoaderListener создает корневой контекст приложения и будет использоваться всеми дочерними контекстами, созданными всеми DispatcherServlet.',
        'SPRING', false),
       ('Расскажите про паттерн MVC, как он реализован в Spring?', 'MVC - model view controller - шаблон проектирования из трех компонентов:\n
Model - отвечает за хранение данных\n
View - отвечает за вывод данных на фронте\n
Controller - оперирует моделями и отвечает за обмен данными model с view\n\n
Основная цель MVC отделить бизнес-логику от визуализации.\n
Spring MVC использует одновременно Front controller и MVC, разделение задач обеспечивается использованием независимых компонентов:\n
- Controller, Model, View\n
- DispatcherServlet - главный контроллер, распределяющий задачи\n
- ViewResolver - определяет на основании имени конкретный view\n\n

Порядок работы следующий:\n
1. HTTP запрос принимает DispetcherServlet и определяет контроллер с помощью HandlerMapping\n
2. HandlerAdapter отправляет в метод контроллера, затем контроллер формирует данные и в виде ModelAndView возвращает их диспетчеру\n
3. Дальше диспетчер с помощью ViewResolver определяет какой именно view нужен\n
- в случае с REST диспетчер сам отправит данные\n
- в случае обычного запроса данные будут отправлены в виде атрибутов в View где работают Thymeleaf и тд.', 'SPRING',
        true),
       ('Что такое АОП? Как реализовано в спринге?', 'Аспектно-ориентированное программирование (АОП) — это парадигма программирования, целью которой является разделениее основного и служебного функционала, служебный функционал записывается в Аспект-классы(в основе Аспект заключается сквозная логика) Примеры Аспекта - логирование, проверка прав, обработка транзакций, обработка исключений, кэширование и т.д. Это достигается путем добавления дополнительного поведения к существующему коду без изменения самого кода.\n\n
АОП предоставляет возможность реализации сквозной логики в одном месте - т.е. логики, которая применяется к множеству частей приложения - и обеспечения автоматического применения этой логики по всему приложению.\n\n
Аспект в АОП - это модуль или класс, реализующий сквозную функциональность. Аспект изменяет поведение остального кода, применяя совет в точках соединения, определённых некоторым срезом.\n
Совет (advice) – дополнительная логика — код, который должен быть вызван из точки соединения.\n
Точка соединения (join point) — место в выполняемой программе (вызов метода, создание объекта, обращение к переменной), где следует применить совет;\n
Срез (pointcut) — набор точек соединения.\n\n
Подход Spring к АОП заключается в создании "динамических прокси" для целевых объектов и "привязывании" объектов к конфигурированному совету для выполнения сквозной логики.\n\n
Есть два варианта создания прокси-класса:\n
1. либо он должен наследоваться от оригинального класса (CGLIB) и переопределять его методы, добавляя нужную логику;\n
2. либо он должен имплементировать те же самые интерфейсы, что и первый класс (Dynamic Proxy).', 'SPRING', true),
       ('В чем разница между Filters, Listeners and Interceptors?', 'Концептуально всё просто, фильтры сервлетов могут перехватывать только HTTPServlets. Listeners могут перехватывать специфические события. Как перехватить события которые относятся ни к тем не другим?\n
Фильтры и перехватчики делают по сути одно и тоже: они перехватывают какое-то событие, и делают что-то до или после.\n
Java EE использует термин Filter, Spring называет их Interceptors.\n
Именно здесь AOP используется в полную силу, благодаря чему возможно перехватывание вызовов любых объектов', 'SPRING',
        false),
       ('Можно ли передать в запросе один и тот же параметр несколько раз? Как?', 'Да, можно принять все значения, используя массив в методе контроллера:\n
public String method(@RequestParam(value="name") String[] names){...}\n
или\n
public String getFoos(@RequestParam List<String> id){...}', 'SPRING', false),
       ('Как работает Spring Security? Как сконфигурировать? Какие интерфейсы используются?', 'Основными блоками Spring Security являются:\n
- SecurityContextHolder, чтобы обеспечить доступ к SecurityContext.\n
- SecurityContext, содержит объект Authentication и в случае необходимости информацию системы безопасности, связанную с запросом.\n
- Authentication представляет принципала с точки зрения Spring Security\n
- GrantedAuthority отражает разрешения выданные доверителю в масштабе всего приложения.\n
- UserDetails предоставляет необходимую информацию для построения объекта Authentication из DAO объектов приложения или других источника данных системы безопасности.\n
- UserDetailsService, чтобы создать UserDetails, когда передано имя пользователя в виде String (или идентификатор сертификата или что-то подобное).',
        'SPRING', false),
       ('Что такое SpringBoot? Какие у него преимущества? Как конфигурируется? Подробно.', 'Spring Boot - это модуль Spring-а, который предоставляет функцию RAD для среды Spring (Rapid Application Development - Быстрая разработка приложений). Он обеспечивает более простой и быстрый способ настройки и запуска как обычных, так и веб-приложений. Он просматривает наши пути к классам и настроенные нами бины, делает разумные предположения о том, чего нам не хватает, и добавляет эти элементы.\n\n  Ключевые особенности и преимущества Spring Boot:\n
1. Простота управления зависимостями (spring-boot-starter-* в pom.xml).\n
2. Автоматическая конфигурация. Включается аннотацией @EnableAutoConfiguration.\n
3. Встроенная поддержка сервера приложений/контейнера сервлетов (Tomcat, Jetty).\n
4. Готовые к работе функции, такие как метрики, проверки работоспособности, security и внешняя конфигурация.\n
5. Инструмент CLI (command-line interface) для разработки и тестирования приложения Spring Boot.\n
6. Минимизация boilerplate кода (код, который должен быть включен во многих местах практически без изменений), конфигурации XML и аннотаций.\n\n
Как происходит автоконфигурация в Spring Boot:\n
\t1. Отмечаем main класс аннотацией @SpringBootApplication (аннотация инкапсулирует в себе: @SpringBootConfiguration, @ComponentScan, @EnableAutoConfiguration), таким образом наличие @SpringBootApplication включает сканирование компонентов, автоконфигурацию и показывает разным компонентам Spring (например, интеграционным тестам), что это Spring Boot приложение.\n
\t2. @EnableAutoConfiguration импортирует класс EnableAutoConfigurationImportSelector. Этот класс не объявляет бины сам, а использует фабрики.\n
\t3. Класс EnableAutoConfigurationImportSelector импортирует ВСЕ (более 150) перечисленные в META-INF/spring.factories конфигурации,  Каждая из этих конфигураций пытается сконфигурировать различные аспекты приложения (web, JPA, AMQP и т.д.), регистрируя нужные бины в контекст приложения.\n
\t4. Логика при регистрации бинов управляется набором @ConditionalOn* аннотаций. Можно указать, чтобы бин создавался при наличии класса в classpath (@ConditionalOnClass), наличии существующего бина (@ConditionalOnBean), отсуствии бина (@ConditionalOnMissingBean) и т.п. Таким образом наличие конфигурации не значит, что бин будет создан и зачастую конфигурация ничего делать и создавать не будет.\n
\t5. Созданный в итоге AnnotationConfigEmbeddedWebApplicationContext ищет в том же DI контейнере фабрику для запуска embedded servlet container.\n
\t6. Servlet container запускается, приложение готово к работе', 'SPRING', true),
       ('Что такое Spring Data JPA?',
        'Spring Data JPA - это часть фреймворка Spring, которая упрощает разработку приложений с доступом к данным на Java с использованием JPA. Она предоставляет высокоуровневый API для определения сущностей, выполнения запросов и управления транзакциями, абстрагируясь от сложных деталей JPA.',
        'SPRING', false),
       ('Как сделать подключение к разным БД?',
        'Для подключения к разным базам данных в Spring можно использовать множественные источники данных. Создайте несколько объектов DataSource и свяжите их с именованными источниками данных в Spring. Затем используйте аннотацию @DataSource для указания источника данных для конкретного репозитория или метода.',
        'SPRING', false),
       ('Расскажите про аннотацию @Query?', 'если в запросе более 1-2 параметров или несколько *join* ,то удобнее использовать аннотацию *@Query*.\n
Для этого в репозитории создаем метод, аннотированный *@Query*, и внутри аннотации прописываем запрос — можно как JPQL, так и native SQL.',
        'SPRING', false),
       ('Что такое проекционный интерфейс (projection interface)?', 'В Java, проекционные интерфейсы обычно связаны с интерфейсами, которые применяются в функциональном программировании для проецирования (проекции) значений из коллекций или потоков данных.\n
Проекционные интерфейсы могут использоваться для обработки последовательностей, фильтрации, преобразования данных и других операций на элементах коллекции. Например, в Java 8 и более поздних версиях были представлены функциональные интерфейсы, такие как Function, Predicate, Consumer и другие, которые могут применяться при работе с проекционными интерфейсами.',
        'SPRING', false),
       ('Как избавиться от циклической зависимости бинов?', '- Редактирование исходного кода некоторых классов, чтобы конфигурирование осуществлялось **с помощью сеттеров, а не конструкторов.\n
- Указать Spring лениво (@Lazy) инициализировать один из bean-компонентов. Таким образом, вместо полной инициализации bean-компонента будет создан прокси-сервер для его внедрения в другой bean-компонент. Внедренный bean-компонент будет полностью создан только тогда, когда он впервые понадобится.\n
- Внедрить зависимость с помощью @Autowired` в один из bean-компонентов**, а затем использовать метод, аннотированный с помощью @PostConstruct, для установки другой зависимости.',
        'SPRING', false),
       ('Расскажите про нововведения Spring 5.', '● Используется JDK 8+ (Optional, CompletableFuture, Time API, java.util.function, default methods)\n
● Поддержка Java 9 (Automatic-Module-Name in 5.0, module-info in 6.0+, ASM 6)\n
● Поддержка HTTP/2 (TLS, Push), NIO/NIO.2\n
● Поддержка Kotlin\n
● Реактивность (веб-инфраструктура с реактивным стеком, «Spring WebFlux»)\n
● Null-safety аннотации(@Nullable), новая документация\n
● Совместимость с Java EE 8 (Servlet 4.0, Bean Validation 2.0, JPA 2.2, JSON Binding API 1.0)\n
● Поддержка JUnit 5 + Testing Improvements (conditional and concurrent)\n
● Удалена поддержка: Portlet, Velocity, JasperReports, XMLBeans, JDO, Guava', 'SPRING', false),
       ('Что такое DDL? Какие операции в него входят? Рассказать про них.', 'DDL (Data Definition Language) -  операторы определения данных (Data Definition Language, DDL):\n\n
- CREATE создает объект БД (базу, таблицу, представление, пользователя и т. д.),\n
- ALTER изменяет объект,\n
- DROP удаляет объект;\n
- TRUNCATE удаляет таблицу и создает её пустую заново, но если в таблице были foreigh key, то создать таблицу не получится. Rollback после TRUNCATE невозможен',
        'SQL_DATABASE', false),
       ('Что такое DML? Какие операции в него входят? Рассказать про них.', 'операторы манипуляции данными (Data Manipulation Language, DML):\n\n
- SELECT выбирает данные, удовлетворяющие заданным условиям,\n
- INSERT добавляет новые данные,\n
- UPDATE изменяет существующие данные,\n
DELETE удаляет данные при выполнении условия WHERE;', 'SQL_DATABASE', false),
       ('Что такое TCL? Какие операции в него входят? Рассказать про них.', 'операторы управления транзакциями (Transaction Control Language, TCL):\n\n
- BEGIN служит для определения начала транзакции\n
- COMMIT применяет транзакцию,\n
- ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции,\n
- SAVEPOINT разбивает транзакцию на более мелкие.', 'SQL_DATABASE', false),
       ('Что такое DCL? Какие операции в него входят? Рассказать про них.', 'операторы определения доступа к данным (Data Control Language, DCL):\n\n
- GRANT предоставляет пользователю (группе) разрешения на определенные операции с объектом,\n
- REVOKE отзывает ранее выданные разрешения,\n
- DENY задает запрет, имеющий приоритет над разрешением;', 'SQL_DATABASE', false),
       ('Нюансы работы с NULL в SQL. Как проверить поле на NULL?', 'NULL - специальное значение (псевдозначение), которое может быть записано в поле таблицы базы данных.\n NULL соответствует понятию «пустое поле», то есть «поле, не содержащее никакого значения».\n\n
NULL означает отсутствие, неизвестность информации.\n Значение NULL не является значением в полном смысле слова: по определению оно означает отсутствие значения и не принадлежит ни одному типу данных. Поэтому NULL не равно ни логическому значению FALSE, ни пустой строке, ни 0. При сравнении NULL с любым значением будет получен результат NULL, а не FALSE и не 0. Более того, NULL не равно NULL!\n\n
команды: IS NULL, IS NOT NULL', 'SQL_DATABASE', false),
       ('Виды Join’ов?', '- INNER JOIN (Простой JOIN): Возвращает строки, которые имеют соответствующие значения в обеих таблицах. Если нет совпадения, строка не возвращается.\n
SELECT *FROM table1 INNER JOIN table2 ON table1.column = table2.column;\n\n
- LEFT (OUTER) JOIN: Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если нет совпадения, для правой таблицы возвращаются NULL значения.\n
SELECT *FROM table1 JOIN table2 ON table1.column = table2.column;\n\n
- RIGHT (OUTER) JOIN: Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если нет совпадения, для левой таблицы возвращаются NULL значения.\n
SELECT *FROM table1 RIGHT JOIN table2 ON table1.column = table2.column;\n\n
- FULL (OUTER) JOIN: Возвращает строки, если они имеют соответствие в одной из таблиц. Если нет совпадения, для недостающих значений возвращаются NULL.\n\n
- CROSS JOIN - перекрестное (или декартово) произведение. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц. Аналогичного результата можно достичь просто перечислив таблицы в FROM через запятую.',
        'SQL_DATABASE', false),
       ('Что лучше использовать join или подзапросы? Почему?', 'Обычно лучше использовать JOIN, поскольку в большинстве случаев он более понятен и лучше оптимизируется СУБД (но 100% этого гарантировать нельзя). Так же JOIN имеет заметное преимущество над подзапросами в случае, когда список выбора SELECT содержит столбцы более чем из одной таблицы.\n\n
Подзапросы лучше использовать в случаях, когда нужно вычислять агрегатные значения и использовать их для сравнений во внешних запросах.',
        'SQL_DATABASE', false),
       ('Что делает UNION?', 'В языке SQL ключевое слово UNION применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих записей. Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах. Необходимо отметить, что UNION сам по себе не гарантирует порядок записей. Записи из второго запроса могут оказаться в начале, в конце или вообще перемешаться с записями из первого запроса. В случаях, когда требуется определенный порядок, необходимо использовать ORDER BY.\n\n
Разница между UNION и UNION ALL заключается в том, что UNION будет пропускать дубликаты записей, тогда как UNION ALL будет включать дубликаты записей.',
        'SQL_DATABASE', false),
       ('Чем WHERE отличается от HAVING ( ответа про то что используются в разных частях запроса - недостаточно)?', 'WHERE нельзя использовать с агрегатными функциями, HAVING можно (предикаты тоже).\n\n
В HAVING можно использовать псевдонимы только если они используются для наименования результата агрегатной функции, в WHERE можно всегда.\n\n
HAVING стоит после GROUP BY, но может использоваться и без него. При отсутствии предложения GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну строку, если выходной набор не пуст.
', 'SQL_DATABASE', false),
       ('Что такое ORDER BY?',
        'ORDER BY (сортировка по выбранному столбцу)  упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленные столбцы упорядочиваются один внутри другого. Возможно определять возрастание ASC или убывание DESC для каждого столбца. По умолчанию установлено - возрастание.',
        'SQL_DATABASE', false),
       ('Что такое DISTINCT?',
        'DISTINCT (исключает дублирование строк)  указывает, что для вычислений используются только уникальные значения столбца. После SELECT и перед FROM. ',
        'SQL_DATABASE', false),
       ('Что такое GROUP BY?', 'GROUP BY (группировка данных) используется для агрегации записей результата по заданным атрибутам.\n
Cоздает отдельную группу для всех возможных значений (включая значение NULL)\n
При использовании GROUP BY все значения NULL считаются равными.', 'SQL_DATABASE', false),
       ('Что быстрее убирает дубликаты distinct или group by?', 'Быстрее убирает дубликаты оператор DISTINCT.\n\n
DISTINCT просто фильтрует дубликаты, не группируя данные. Это более эффективная операция, особенно для больших наборов данных.\n\n
GROUP BY, с другой стороны, сначала группирует данные по указанным столбцам, а затем возвращает одну строку для каждой группы. Это более дорогостоящая операция, поскольку она требует дополнительной обработки для группировки данных.',
        'SQL_DATABASE', false),
       ('Что такое LIMIT?', 'Позволяет ограничить количество выводимых записей. После FROM', 'SQL_DATABASE', false),
       ('Что такое EXISTS?',
        'EXISTS берет подзапрос, как аргумент, и оценивает его как TRUE, если подзапрос возвращает какие-либо записи и FALSE, если нет.',
        'SQL_DATABASE', false),
       ('Расскажите про операторы IN, BETWEEN, LIKE.', '• IN - определяет наличие данных в масиве.\n
SELECT * FROM Persons WHERE name IN (''Ivan'',''Petr'',''Pavel'');\n\n
• BETWEEN определяет диапазон значений. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку.\n
SELECT * FROM Persons WHERE age BETWEEN 20 AND 25;\n\n
• LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. В качестве условия используются символы шаблонизации (wildkards) - специальные символы, которые могут соответствовать чему-нибудь: % Любая строка, содержащая ноль или более символов _ (подчеркивание) Любой одиночный символ\n\n\n
_ замещает любой одиночный символ. Например, ''b_t'' будет соответствовать словам ''bat'' или ''bit'', но не будет соответствовать ''brat''.\n
% замещает последовательность любого числа символов. Например ''%p%t'' будет соответствовать словам ''put'', ''posit'', или ''opt'', но не ''spite''.\n
SELECT * FROM UNIVERSITY WHERE NAME LIKE ''%o'';', 'SQL_DATABASE', false),
       ('Что делает оператор MERGE? Какие у него есть ограничения?', 'MERGE позволяет осуществить слияние данных одной таблицы с данными другой таблицы. При слиянии таблиц проверяется условие, и если оно истинно, то выполняется UPDATE, а если нет - INSERT. При этом изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц, нельзя.\n\n
MERGE Ships AS t  -- таблица, которая будет меняться\n
USING (SELECT запрос ) AS s ON (t.name = s.ship)  -- условие слияния\n
    THEN UPDATE SET t.launched = s.year -- обновление\n
WHEN NOT MATCHED -- если условие не выполняется\n
    THEN INSERT VALUES(s.ship, s.year) -- вставка', 'SQL_DATABASE', false),
       ('Какие агрегатные функции вы знаете?', 'Агрегатных функции - функции, которые берут группы значений и сводят их к одиночному значению.\n\n
Несколько агрегатных функций:\n
COUNT - производит подсчет записей, удовлетворяющих условию запроса;\n
CONCAT - соединяет строки;\n
SUM - вычисляет арифметическую сумму всех значений колонки;\n
AVG - вычисляет среднее арифметическое всех значений;\n
MAX - определяет наибольшее из всех выбранных значений;\n
MIN - определяет наименьшее из всех выбранных значений.', 'SQL_DATABASE', false),
       ('Что такое ограничения (constraints)? Какие вы знаете?', 'Ограничения - это ключевае слова, которые помогают установить правила размещения данных в базе. Используются при создании БД.\n\n
- NOT NULL указывает, что значение не может быть пустым.\n
- UNIQUE обеспечивает отсутствие дубликатов.\n
- PRIMARY KEY - комбинация NOT NULL и UNIQUE. Помечает каждую запись в базе данных уникальным значением.\n
- CHECK проверяет вписывается ли значение в заданный диапазон ( s_id int CHECK(s_id > 0) )\n
- FOREIGN KEY создает связь между двумя таблицами и защищает от действий, которые могут нарушить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой.\n
- DEFAULT устанавливает значение по умолчанию, если значения не предоствлено (name VARCHAR(20) DEFAULT "noname").\n\n
Какие отличия между PRIMARY и UNIQUE?\n
По умолчанию PRIMARY создает кластерный индекс на столбце, а UNIQUE - некластерный. PRIMARY не разрешает NULL записей, в то время как UNIQUE разрешает одну (а в некоторых СУБД несколько) NULL запись.\n
Таблица может иметь один PRIMARY KEY и много UNIQUE.\n\n
Может ли значение в столбце, на который наложено ограничение FOREIGN KEY, равняться NULL?\n
Может, если на данный столбец не наложено ограничение NOT NULL.', 'SQL_DATABASE', false),
       ('Что такое суррогатные ключи?',
        'Суррога́тный ключ — это дополнительное служебное поле, автоматически добавленное к уже имеющимся информационным полям таблицы, предназначение которого — служить первичным ключом.',
        'SQL_DATABASE', true),
       ('Что такое индексы? Какие они бывают?', 'Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает структуру для индексируемого поля. Необходимо просто добавить указатель индекса в таблицу.\n\n
Содержит структуры бинарных деревьев\n\n
Есть три типа индексов, а именно:\n
1. Уникальный индекс (Unique Index): этот индекс не позволяет полю иметь повторяющиеся значения. Если первичный ключ определен, уникальный индекс применен автоматически.\n\n
2. Кластеризованный индекс (Clustered Index): Кластеризованный индекс хранит реальные строки данных в листьях индекса. Возвращаясь к предыдущему примеру, это означает что строка данных, связанная со значение ключа, равного 123 будет храниться в самом индексе. Важной характеристикой кластеризованного индекса является то, что все значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица или представление может иметь только один кластеризованный индекс. В дополнение следует отметить, что данные в таблице хранятся в отсортированном виде только в случае если создан кластеризованный индекс у этой таблицы.\n
Таблица не имеющая кластеризованного индекса называется кучей.\n\n
3. Некластеризованный индекс (Non-Clustered Index): Создаются только после клатерного индекса, создаются автоматически при объявлении столбца UNIQUE.В отличие от кластеризованного индекса, листья некластеризованного индекса содержат только те столбцы (ключевые), по которым определен данный индекс, а также содержит указатель на строки с реальными данными в таблице. Это означает, что системе подзапросов необходима дополнительная операция для обнаружения и получения требуемых данных. Содержание указателя на данные зависит от способа хранения данных: кластеризованная таблица или куча. Если указатель ссылается на кластеризованную таблицу, то он ведет к кластеризованному индексу, используя который можно найти реальные данные.',
        'SQL_DATABASE', true),
       ('Чем TRUNCATE отличается от DELETE?', 'DELETE - оператор DML, удаляет записи из таблицы, которые удовлетворяют условиям WHERE. Медленнее, чем TRUNCATE. Есть возможность восстановить данные.\n\n
TRUNCATE - DDL оператор, удаляет все строки из таблицы. Нет возможность восстановить данные - сделать ROLLBACK.
', 'SQL_DATABASE', false),
       ('Что такое хранимые процедуры? Для чего они нужны?', 'Хранимая процедура — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Плюс в том что компилируются только 1 раз что увеличивает производительность.\n\n Хранимые процедуры очень похожи на обыкновенные методы языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения.\n\n
Хранимые процедуры позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.',
        'SQL_DATABASE', true),
       ('Что такое представления (VIEW)? Для чего они нужны?', 'View - (Псевдонимы для запросов SELECT) виртуальная таблица, представляющая данные одной или более таблиц альтернативным образом. Нужны для ограничения доступа к данным и также для сокрытия реализации\n\n
В действительности представление – всего лишь результат выполнения оператора SELECT, который хранится в структуре памяти, напоминающей SQL таблицу. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления значительно расширяют возможности управления данными. Это способ дать публичный доступ к некоторой (но не всей) информации в таблице.\n\n
Представления могут основываться как на таблицах, так и на других представлениях, т.е. могут быть вложенными (до 32 уровней вложенности).',
        'SQL_DATABASE', false),
       ('Что такое временные таблицы? Для чего они нужны?', 'Подобные таблицы удобны для каких-то временных промежуточных выборок из нескольких таблиц.\n\n
Создание временной таблицы начинается со знака решетки #. Если используется один знак #, то создается локальная таблица, которая доступна в течение текущей сессии. Ели используются два знака ##, то создается глобальная временная таблица(живет пока открыт SQL Management ). В отличие от локальной глобальная временная таблица доступна всем открытым сессиям базы данных.\n\n
    CREATE TABLE #ProductSummary\n
    (ProdId INT IDENTITY,\n
    ProdName NVARCHAR(20),\n
    Price MONEY)', 'SQL_DATABASE', false),
       ('Что такое транзакции? Расскажите про принципы ACID.', 'Транзакция - (совокупность операций над данными как чтения так и записи) это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в изменении данных, хранящихся в базе данных.\n\n
ACID-принципы транзакций:\n
    • Атомарность (atomicity) гарантирует, что транзакция будет полностью выполнена или потерпит неудачу, где транзакция представляет одну логическую операцию данных. Это означает, что при сбое одной части любой транзакции происходит сбой всей транзакции и состояние базы данных остается неизменным.\n\n
    • Согласованность (consistency). Транзакция, достигающая своего завершения и фиксирующая свои результаты, сохраняет согласованность базы данных\n\n
    • Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на ее результат.\n\n
    • Долговечность (durability). Независимо от проблем (к примеру, потеря питания, сбой или ошибки любого рода) изменения, сделанные успешно завершённой транзакцией, должны остаться сохраненными после возвращения системы в работу.',
        'SQL_DATABASE', true),
       ('Расскажите про уровни изолированности транзакций.', 'При параллельных транзакциях могут возникать некоторые проблемы:\n\n
1. Lost Update - потерянное обновление. Происходит, когда обе транзакции одновременно обновляют данные и затем вторая транзакция откатывает изменения, вследствие чего изменения обеих транзакций теряются. Данная проблема решена во всех современных СУБД\n\n
2. Dirty Read - “грязное” чтение. Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция в итоге будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе.\n\n
3. Non-Repeatable Read - неповторяющееся чтение. Происходит, когда первая транзакция читает одни и те же данные дважды, но после первого прочтения вторая транзакция изменяет (update) эти же данные и делает коммит, вследствие чего вторая выборка в первой транзакции вернет другой результат.\n\n
4. Phantom Read - фантомное чтение. Происходит, когда первая транзакция читает одни и те же данные дважды, но после первого прочтения вторая транзакция добавляет новые строки или удаляет старые и делает коммит, вследствие чего вторая выборка в первой транзакции вернет другой результат (разное количество записей).\n\n\n
    **Уровни изоляции в SQL**\n\n
1. Read Uncommitted\n
Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение «грязных» (незафиксированных) данных.\n\n
Однако в PostgreSQL требования, предъявляемые к этому уровню, более строгие, чем в стандарте: чтение «грязных» данных на этом уровне не допускается.\n\n
2. Read Committed\n
Не допускается чтение «грязных» (незафиксированных) данных. Транзакция может видеть только те незафиксированные изменения данных, которые произведены в ходе выполнения ее самой.\n\n
3. Repeatable Read\n
Не допускается чтение «грязных» (незафиксированных) данных и неповторяющееся чтение. В PostgreSQL на этом уровне не допускается также фантомное чтение.\n\n
4. Serializable\n
Не допускается ни один из феноменов, перечисленных выше, в том числе и аномалии сериализации.', 'SQL_DATABASE', true),
       ('Что такое нормализация и денормализация? Расскажите про 3 нормальные формы?', '1. Нормализация - это процесс организации, структуризации данных в базе, который обеспечивает большую гибкость базы данных за счет исключения избыточности и несогласованности зависимостей.\n
Целью является уменьшение потенциальной противоречивости хранимой в базе данных информации.\n\n
2. Денормализация базы данных — намеренное снижение или нарушение форм  нормализации базы данных, обычно — чтобы ускорить чтение из базы за счет добавления избыточных данных. В общем, это процесс, обратный к нормализации.\n
Так происходит потому, что теория нормальных форм не всегда применима на практике.\n\n
Каждая нормальная форма включает в себя предыдущую. 3 Типа форм:\n
- Первая нормальная форма (1NF) - значения всех полей атомарны (неделимы), нет множества значений в одном поле.\n
- Вторая нормальная форма (2NF) - все неключевые поля зависят только от ключа целиком, а не от какой-то его части.\n
- Третья нормальная форма (3NF) - все неключевые поля не зависят друг от друга.', 'SQL_DATABASE', true),
       ('Что такое TIMESTAMP?', 'DATETIME предназначен для хранения целого числа: YYYYMMDDHHMMSS. И это время не зависит от временной зоны настроенной на сервере. Размер: 8 байт\n\n
TIMESTAMP хранит значение равное количеству секунд, прошедших с полуночи 1 января 1970 года по усреднённому времени Гринвича. Тогда была создана Unix. При получении из базы отображается с учётом часового пояса. Размер: 4 байта',
        'SQL_DATABASE', false),
       ('Шардирование БД', 'При большом количестве данных запросы начинают долго выполняться, и сервер начинает не справляться с нагрузкой.\n    Одно из решений, что с этими данными делать — это масштабирование базы данных. Например, шардинг или репликация.    Суть Шардинга заключается в разделении БД на отедльные части так чтобы каждую из них можно было вынести на отдельный сервер\n\n
Шардинг бывает вертикальным(партицирование) и горизонтальным.
    1. Вертикальный шардинг - это выделение таблицы или группы таблиц на отдельный сервер.\n
    2. Горизонтальный - это разделение одной таблицы на разные сервера.\n
Единственное отличие горизонтального масштабирования от вертикального в том, что горизонтальное будет разносить данные по разным инстансам в других базах.',
        'SQL_DATABASE', false),
       ('EXPLAIN', 'Оператор EXPLAIN в SQL используется для анализа и оценки запросов SELECT в базе данных. Он выводит информацию о том, как база данных будет выполнять запрос, например, какие индексы будут использоваться, в каком порядке будут объединяться таблицы и т. д. Анализ плана выполнения запроса с помощью оператора EXPLAIN помогает оптимизировать запросы и улучшить производительность базы данных.\n\n
      Рассчитывает стоимость на основании двух операций:\n
- page_cost (input-output) - количество считанных сегментов (страниц) с жесткого диска (минимальная единица стоимости - 1.0 )\n
- cpu_cost - количество операций процессора (минимальная единица стоимости - 0.01)', 'SQL_DATABASE', true),
       ('Как сделать запрос из двух баз?', 'Если в запросе таблица указывается с именем базы данных database1.table1, то таблица выбирается из database1, если просто table1, то - из активной базы данных.\n\n
Общий принцип перекрестного запроса к двум базам в пределах одного MySQL-сервера:\n\n
    SELECT t1.*, t2.*\n
    FROM database1.table1 AS t1\n
    INNER JOIN database2.table2 AS t2 ON t2.field1 = t1.field1\n\n
Алиасы t1 и t2 использовать не обязательно. Но они уменьшают размер запроса, и улучшают читабельность.', 'SQL_DATABASE',
        false),
       ('Механизмы оптимизации запросов в БД', '- изменение исходного кода запроса\n
- обновление статистики, на основе которой планировщик строит планы\n
- денормализация: создание временных таблиц или создание индексов\n
- изменение параметров планировщика, управляющих выбором порядка соединения наборов строк\n
- изменение параметров планировщика, управляющих выбором метода доступа к данным (enable_seqscan, enable_indexscan, enable_indexonlyscan, enable_bitmapscan)
- изменение параметров планировщика, управляющих способом соединения наборов строк (enable_nestloop, enable_hashjoin, enable_mergejoin);
- изменение параметров планировщика, управляющих использованием ряда операций: агрегирование на основе хеширования, материализация временных наборов строк, выполнение явной сортировки при наличии других возможностей.',
        'SQL_DATABASE', false),
       ('Что такое «триггер»?', 'Триггер (trigger) — это хранимая процедура, которая не вызывается непосредственно, а исполняется при наступлении определенного события ( вставка, удаление, обновление строки / это хранимая процедура особого типа, исполнение которой обусловлено действием по модификации данных: добавлением, удалением или изменением данных в заданной таблице реляционной базы данных.\n    Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера.\n\n
Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события).',
        'SQL_DATABASE', false);